[
    {
        "exercise": "Design a system for managing a fleet of vehicles in a transportation company. The company has several types of vehicles, including cars, trucks, and buses. Each vehicle has common attributes such as make, model, year, and mileage, but also has specific attributes and behaviors based on its type.\n\nRequirements:\n- Create a base `Vehicle` struct with common attributes and methods.\n- Implement specific vehicle types (Car, Truck, Bus) that inherit from the `Vehicle` struct.\n- Each vehicle type should have its own unique attributes and methods.\n- Implement a `Maintainable` interface with a `PerformMaintenance()` method, which should be implemented by vehicles that require maintenance.\n- Create a `Fleet` struct that manages a collection of vehicles and provides methods to add, remove, and list vehicles.\n- Implement a `VehicleFactory` that creates instances of specific vehicle types based on provided parameters.\n\nDemonstrate the usage of the system by creating a fleet, adding vehicles of different types, and performing operations such as listing vehicles and performing maintenance on eligible vehicles.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    Make     string\n    Model    string\n    Year     int\n    Mileage  int\n}\n\nfunc (v *Vehicle) GetInfo() string {\n    return fmt.Sprintf(\"Make: %s, Model: %s, Year: %d, Mileage: %d\", v.Make, v.Model, v.Year, v.Mileage)\n}\n\ntype Car struct {\n    Vehicle\n    NumDoors int\n}\n\ntype Truck struct {\n    Vehicle\n    CargoCapacity float64\n}\n\nfunc (t *Truck) PerformMaintenance() {\n    fmt.Printf(\"Performing maintenance on truck: %s\\n\", t.GetInfo())\n}\n\ntype Bus struct {\n    Vehicle\n    NumSeats int\n}\n\nfunc (b *Bus) PerformMaintenance() {\n    fmt.Printf(\"Performing maintenance on bus: %s\\n\", b.GetInfo())\n}\n\ntype Maintainable interface {\n    PerformMaintenance()\n}\n\ntype Fleet struct {\n    Vehicles []Vehicle\n}\n\nfunc (f *Fleet) AddVehicle(vehicle Vehicle) {\n    f.Vehicles = append(f.Vehicles, vehicle)\n}\n\nfunc (f *Fleet) RemoveVehicle(index int) {\n    f.Vehicles = append(f.Vehicles[:index], f.Vehicles[index+1:]...)\n}\n\nfunc (f *Fleet) ListVehicles() {\n    for _, vehicle := range f.Vehicles {\n        fmt.Println(vehicle.GetInfo())\n    }\n}\n\nfunc (f *Fleet) PerformMaintenance() {\n    for _, vehicle := range f.Vehicles {\n        if m, ok := vehicle.(Maintainable); ok {\n            m.PerformMaintenance()\n        }\n    }\n}\n\ntype VehicleFactory struct{}\n\nfunc (vf *VehicleFactory) CreateVehicle(vehicleType string, make string, model string, year int, mileage int, options map[string]interface{}) Vehicle {\n    switch vehicleType {\n    case \"car\":\n        return &Car{\n            Vehicle:  Vehicle{Make: make, Model: model, Year: year, Mileage: mileage},\n            NumDoors: options[\"numDoors\"].(int),\n        }\n    case \"truck\":\n        return &Truck{\n            Vehicle:       Vehicle{Make: make, Model: model, Year: year, Mileage: mileage},\n            CargoCapacity: options[\"cargoCapacity\"].(float64),\n        }\n    case \"bus\":\n        return &Bus{\n            Vehicle:  Vehicle{Make: make, Model: model, Year: year, Mileage: mileage},\n            NumSeats: options[\"numSeats\"].(int),\n        }\n    default:\n        return nil\n    }\n}\n\nfunc main() {\n    fleet := &Fleet{}\n    factory := &VehicleFactory{}\n\n    car := factory.CreateVehicle(\"car\", \"Toyota\", \"",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a transportation company. The company has a fleet of cars, trucks, and motorcycles. Each vehicle type has its own specific attributes and methods, but they also share some common characteristics.\n\nCreate an abstract base class called `Vehicle` with the following properties and methods:\n- `make` (string): The make of the vehicle\n- `model` (string): The model of the vehicle\n- `year` (int): The year of manufacture\n- `GetInfo()` (method): Returns a string with the vehicle's make, model, and year\n\nCreate three derived classes: `Car`, `Truck`, and `Motorcycle`, each inheriting from the `Vehicle` class.\n\n- The `Car` class should have an additional property `numDoors` (int) and a method `GetNumDoors()` that returns the number of doors.\n- The `Truck` class should have additional properties `cargoCapacity` (float64) and `towingCapacity` (float64), and methods `GetCargoCapacity()` and `GetTowingCapacity()` that return the respective capacities.\n- The `Motorcycle` class should have an additional property `engineDisplacement` (int) and a method `GetEngineDisplacement()` that returns the engine displacement in cc.\n\nImplement a `VehicleManager` class that keeps track of all the vehicles in the fleet. The `VehicleManager` should have the following methods:\n- `AddVehicle(v Vehicle)`: Adds a vehicle to the fleet\n- `RemoveVehicle(v Vehicle)`: Removes a vehicle from the fleet\n- `GetVehicleInfo()`: Returns a string with information about all the vehicles in the fleet, including their specific attributes\n\nDemonstrate the usage of the `VehicleManager` and the polymorphic behavior of the vehicle classes.",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of vehicles in a transportation company. The company has different types of vehicles, including cars, trucks, and motorcycles. Each vehicle has common properties such as make, model, year, and mileage, but also has specific characteristics based on its type. Cars have a seating capacity, trucks have a cargo capacity, and motorcycles have a type (sports, cruiser, etc.). Implement a polymorphic system that allows for the creation and management of these different vehicle types, including a method to calculate the estimated fuel efficiency for each vehicle based on its type and characteristics.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    make     string\n    model    string\n    year     int\n    mileage  int\n}\n\nfunc (v *Vehicle) getMake() string {\n    return v.make\n}\n\nfunc (v *Vehicle) getModel() string {\n    return v.model \n}\n\nfunc (v *Vehicle) getYear() int {\n    return v.year\n}\n\nfunc (v *Vehicle) getMileage() int {\n    return v.mileage\n}\n\ntype Car struct {\n    Vehicle\n    seatingCapacity int\n}\n\nfunc (c *Car) estimateFuelEfficiency() float64 {\n    return float64(c.mileage) / float64(c.seatingCapacity)\n}\n\ntype Truck struct {\n    Vehicle \n    cargoCapacity int\n}\n\nfunc (t *Truck) estimateFuelEfficiency() float64 {\n    return float64(t.mileage) / float64(t.cargoCapacity)\n}\n\ntype Motorcycle struct {\n    Vehicle\n    motorcycleType string\n}\n\nfunc (m *Motorcycle) estimateFuelEfficiency() float64 {\n    efficiency := float64(m.mileage)\n    if m.motorcycleType == \"sports\" {\n        efficiency *= 0.8\n    } else if m.motorcycleType == \"cruiser\" {\n        efficiency *= 1.2\n    }\n    return efficiency\n}\n\nfunc main() {\n    car := Car{Vehicle{\"Honda\", \"Civic\", 2020, 15000}, 5}\n    truck := Truck{Vehicle{\"Ford\", \"F-150\", 2018, 80000}, 1500}  \n    motorcycle := Motorcycle{Vehicle{\"Harley-Davidson\", \"Sportster\", 2019, 5000}, \"cruiser\"}\n\n    vehicles := []interface{}{&car, &truck, &motorcycle}\n\n    for _, vehicle := range vehicles {\n        switch v := vehicle.(type) {\n        case *Car:\n            fmt.Printf(\"Car: %s %s (%d), Mileage: %d, Seating Capacity: %d, Fuel Efficiency: %.2f\\n\", \n                v.getMake(), v.getModel(), v.getYear(), v.getMileage(), v.seatingCapacity, v.estimateFuelEfficiency())\n        case *Truck:\n            fmt.Printf(\"Truck: %s %s (%d), Mileage: %d, Cargo Capacity: %d, Fuel Efficiency: %.2f\\n\",\n                v.getMake(), v.getModel(), v.getYear(), v.getMileage(), v.cargoCapacity, v.estimateFuelEfficiency())  \n        case *Motorcycle:\n            fmt.Printf(\"Motorcycle: %s %s (%d), Mileage: %d, Type: %s, Fuel Efficiency: %.2f\\n\",\n                v.getMake(), v.getModel(), v.getYear(), v.getMileage(), v.motorcycleType, v.estimateFuelEfficiency())\n        }\n    }\n}\n```",
        "explanation": "This solution demonstrates inheritance and polymorphism in Go using struct embedding and interfaces. The `Vehicle` struct serves as the base type, containing common properties shared by all vehicles. The `Car`, `Truck`, and `Motorcycle` structs embed the `Vehicle` struct, inheriting its fields and methods. Each specific vehicle type also has its own unique properties and an `estimateFuelEfficiency",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system for a simple e-commerce platform using the Go programming language. The system should support the following functionality:\n\n1. Products with properties such as name, description, price, and inventory count\n2. Users with properties such as username, email, and password \n3. Orders containing a list of products, user information, and total price\n4. A shopping cart that allows users to add, remove, and update products before placing an order\n\nYour task is to create the necessary structs, interfaces, and methods to implement this functionality. Ensure proper encapsulation of data and behavior within the appropriate structs. Also, demonstrate usage of your system by creating a sample user, adding products to their shopping cart, and placing an order.\n\nBonus: Implement a simple promotion system that applies discounts to orders based on certain criteria (e.g., total order amount, specific products).",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Product struct {\n    Name        string\n    Description string\n    Price       float64\n    Inventory   int\n}\n\ntype User struct {\n    Username string\n    Email    string\n    Password string\n}\n\ntype Order struct {\n    User        User\n    Products    []Product\n    TotalPrice  float64\n    IsPromoted  bool\n    PromotionAmount float64 \n}\n\ntype ShoppingCart struct {\n    User     User\n    Products []Product\n}\n\nfunc (sc *ShoppingCart) AddProduct(p Product) {\n    sc.Products = append(sc.Products, p)\n}\n\nfunc (sc *ShoppingCart) RemoveProduct(index int) {\n    sc.Products = append(sc.Products[:index], sc.Products[index+1:]...)\n}\n\nfunc (sc *ShoppingCart) UpdateProductQuantity(index, quantity int) {\n    sc.Products[index].Inventory = quantity\n}\n\nfunc (sc *ShoppingCart) Checkout() Order {\n    totalPrice := 0.0\n    for _, p := range sc.Products {\n        totalPrice += p.Price * float64(p.Inventory)\n    }\n    return Order{\n        User:       sc.User,\n        Products:   sc.Products,\n        TotalPrice: totalPrice,\n    }\n}\n\ntype PromotionChecker interface {\n    IsPromotionApplicable(order Order) (bool, float64)\n}\n\ntype AmountPromotion struct {\n    MinAmount float64\n    Discount  float64\n}\n\nfunc (ap AmountPromotion) IsPromotionApplicable(order Order) (bool, float64) {\n    if order.TotalPrice >= ap.MinAmount {\n        return true, order.TotalPrice * ap.Discount\n    }\n    return false, 0\n}\n\nfunc main() {\n    // Create sample products\n    p1 := Product{Name: \"Product 1\", Description: \"Description 1\", Price: 10.0, Inventory: 5}\n    p2 := Product{Name: \"Product 2\", Description: \"Description 2\", Price: 20.0, Inventory: 3}\n\n    // Create a user\n    user := User{Username: \"john_doe\", Email: \"john@example.com\", Password: \"password123\"}\n\n    // Create a shopping cart and add products\n    cart := ShoppingCart{User: user}\n    cart.AddProduct(p1)\n    cart.AddProduct(p2)\n\n    // Place an order\n    order := cart.Checkout()\n\n    // Apply promotions\n    promos := []PromotionChecker{\n        AmountPromotion{MinAmount: 50, Discount: 0.1},\n    }\n    for _, promo := range promos {\n        if applicable, discount := promo.IsPromotionApplicable(order); applicable {\n            order.IsPromoted = true\n            order.PromotionAmount = discount\n            break\n        }\n    }\n\n    fmt.Printf(\"Order placed:\\nUser: %s\\nTotal: $%.2f\\nPromoted: %t\\nPromotion Amount: $%.2f\\n\",\n        order.User.Username, order.TotalPrice, order.IsPromoted, order.PromotionAmount)\n}",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a library's book collection using object-oriented principles in Go. The system should support the following functionalities:\n\n1. Adding new books to the library's collection\n2. Searching for books by title, author, or ISBN\n3. Checking out books to library members\n4. Returning books to the library\n5. Calculating late fees for overdue books\n\nYour task is to create the necessary structs and methods to implement this library management system. Consider factors such as encapsulation, inheritance, and polymorphism in your design. You should also handle edge cases and provide appropriate error messages.\n\nIn addition to the code, provide a brief explanation of your design choices and how they adhere to object-oriented principles.",
        "answer": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Book struct {\n\tTitle  string\n\tAuthor string\n\tISBN   string\n}\n\ntype LibraryMember struct {\n\tName string\n\tID   int\n}\n\ntype BookItem struct {\n\tBook     Book\n\tDueDate  time.Time\n\tBorrower *LibraryMember\n}\n\ntype Library struct {\n\tBooks   []BookItem\n\tMembers []LibraryMember\n}\n\nfunc (l *Library) AddBook(book Book) {\n\tl.Books = append(l.Books, BookItem{Book: book})\n}\n\nfunc (l *Library) FindBooksByTitle(title string) []Book {\n\tvar matchingBooks []Book\n\tfor _, item := range l.Books {\n\t\tif item.Book.Title == title {\n\t\t\tmatchingBooks = append(matchingBooks, item.Book)\n\t\t}\n\t}\n\treturn matchingBooks\n}\n\nfunc (l *Library) FindBooksByAuthor(author string) []Book {\n\tvar matchingBooks []Book\n\tfor _, item := range l.Books {\n\t\tif item.Book.Author == author {\n\t\t\tmatchingBooks = append(matchingBooks, item.Book)\n\t\t}\n\t}\n\treturn matchingBooks\n}\n\nfunc (l *Library) FindBookByISBN(isbn string) (Book, error) {\n\tfor _, item := range l.Books {\n\t\tif item.Book.ISBN == isbn {\n\t\t\treturn item.Book, nil\n\t\t}\n\t}\n\treturn Book{}, errors.New(\"Book not found\")\n}\n\nfunc (l *Library) CheckoutBook(isbn string, member LibraryMember, dueDate time.Time) error {\n\tfor i, item := range l.Books {\n\t\tif item.Book.ISBN == isbn {\n\t\t\tif item.Borrower != nil {\n\t\t\t\treturn errors.New(\"Book is already checked out\")\n\t\t\t}\n\t\t\tl.Books[i].Borrower = &member\n\t\t\tl.Books[i].DueDate = dueDate\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"Book not found\")\n}\n\nfunc (l *Library) ReturnBook(isbn string) error {\n\tfor i, item := range l.Books {\n\t\tif item.Book.ISBN == isbn {\n\t\t\tif item.Borrower == nil {\n\t\t\t\treturn errors.New(\"Book is not checked out\")\n\t\t\t}\n\t\t\tl.Books[i].Borrower = nil\n\t\t\tl.Books[i].D",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system in Go to represent a university. The system should include the following entities and relationships:\n\n- University: Represents the university itself and contains multiple Departments.\n- Department: Represents an academic department within the university and contains multiple Courses and Professors. Each department has a name and a head professor.\n- Course: Represents a course offered by a department. Each course has a name, code, and assigned professor.\n- Professor: Represents a faculty member who teaches courses. Each professor has a name, ID, and the courses they teach.\n- Student: Represents a student enrolled in the university. Each student has a name, ID, and the courses they are enrolled in.\n\nImplement the necessary structs, methods, and relationships to create a functioning university system. Ensure proper encapsulation and use appropriate inheritance and composition relationships.\n\nThe system should allow for the following operations:\n- Add a new department to the university\n- Add a new course to a department\n- Assign a professor to a course\n- Enroll a student in a course\n- Print the details of a department, including its courses and professors\n- Print the details of a student, including their enrolled courses",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype University struct {\n    Departments []*Department\n}\n\nfunc (u *University) AddDepartment(dept *Department) {\n    u.Departments = append(u.Departments, dept)\n}\n\ntype Department struct {\n    Name      string\n    HeadProf  *Professor\n    Courses   []*Course\n    Professors []*Professor\n}\n\nfunc (d *Department) AddCourse(course *Course) {\n    d.Courses = append(d.Courses, course)\n}\n\nfunc (d *Department) AssignProfessorToCourse(prof *Professor, course *Course) {\n    course.Professor = prof\n    prof.Courses = append(prof.Courses, course)\n}\n\nfunc (d *Department) PrintDetails() {\n    fmt.Printf(\"Department: %s\\n\", d.Name)\n    fmt.Printf(\"Head Professor: %s\\n\", d.HeadProf.Name)\n    fmt.Println(\"Courses:\")\n    for _, course := range d.Courses {\n        fmt.Printf(\"- %s (code: %s), Professor: %s\\n\", course.Name, course.Code, course.Professor.Name)\n    }\n    fmt.Println(\"Professors:\")\n    for _, prof := range d.Professors {\n        fmt.Printf(\"- %s (ID: %s)\\n\", prof.Name, prof.ID)\n    }\n}\n\ntype Course struct {\n    Name      string\n    Code      string\n    Professor *Professor\n    Students  []*Student\n}\n\nfunc (c *Course) EnrollStudent(student *Student) {\n    c.Students = append(c.Students, student)\n    student.Courses = append(student.Courses, c)\n}\n\ntype Professor struct {\n    Name    string\n    ID      string\n    Courses []*Course\n}\n\ntype Student struct {\n    Name    string\n    ID      string\n    Courses []*Course\n}\n\nfunc (s *Student) PrintDetails() {\n    fmt.Printf(\"Student: %s (ID: %s)\\n\", s.Name, s.ID)\n    fmt.Println(\"Enrolled Courses:\")\n    for _, course := range s.Courses {\n        fmt.Printf(\"- %s (code: %s), Professor: %s\\n\", course.Name, course.Code, course.Professor.Name)\n    }\n}\n\nfunc main() {\n    // Create a university\n    university := &University{}\n\n    // Create departments\n    csDept := &Department{Name: \"Computer Science\"}\n    mathDept := &Department{Name: \"Mathematics\"}\n\n    // Create professors\n    csProf := &Professor{Name: \"Dr. Smith\", ID: \"P001\"}\n    mathProf := &Professor{Name: \"Dr. Johnson\", ID: \"P002\"}\n\n    // Create courses\n    csCourse1 := &Course{Name: \"Intro to Programming\", Code: \"CS101\"}\n    csCourse2 := &Course",
        "level": "advanced"
    },
    {
        "exercise": "Design a car rental system using object-oriented principles in Go. The system should handle different types of vehicles (e.g., cars, trucks, motorcycles), each with its own set of attributes and methods. The system should also manage rental transactions, including calculating rental fees based on the duration and vehicle type. Implement the following:\n\n1. Define structs for each vehicle type (Car, Truck, Motorcycle) with appropriate fields and methods.\n2. Define an interface named Vehicle that includes methods common to all vehicle types, such as GetRentalRate() and GetDescription().\n3. Implement the Vehicle interface for each vehicle struct.\n4. Create a RentalTransaction struct that includes fields for the rented vehicle, start date, end date, and customer information.\n5. Implement a CalculateRentalFee() method for the RentalTransaction struct that calculates the rental fee based on the vehicle type and rental duration.\n\nDemonstrate the usage of the car rental system by creating sample vehicles, initiating a rental transaction, and calculating the rental fee.",
        "answer": "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\ntype Vehicle interface {\n    GetRentalRate() float64\n    GetDescription() string\n}\n\ntype Car struct {\n    Make  string\n    Model string\n    Year  int\n}\n\nfunc (c Car) GetRentalRate() float64 {\n    return 50.0\n}\n\nfunc (c Car) GetDescription() string {\n    return fmt.Sprintf(\"%s %s (%d)\", c.Make, c.Model, c.Year)\n}\n\ntype Truck struct {\n    Make     string\n    Model    string\n    Year     int\n    Capacity int\n}\n\nfunc (t Truck) GetRentalRate() float64 {\n    return 75.0\n}\n\nfunc (t Truck) GetDescription() string {\n    return fmt.Sprintf(\"%s %s (%d) - Capacity: %d\", t.Make, t.Model, t.Year, t.Capacity)\n}\n\ntype Motorcycle struct {\n    Make  string\n    Model string\n    Year  int\n}\n\nfunc (m Motorcycle) GetRentalRate() float64 {\n    return 30.0\n}\n\nfunc (m Motorcycle) GetDescription() string {\n    return fmt.Sprintf(\"%s %s (%d)\", m.Make, m.Model, m.Year)\n}\n\ntype RentalTransaction struct {\n    Vehicle      Vehicle\n    StartDate    time.Time\n    EndDate      time.Time\n    CustomerName string\n}\n\nfunc (r RentalTransaction) CalculateRentalFee() float64 {\n    days := r.EndDate.Sub(r.StartDate).Hours() / 24\n    return r.Vehicle.GetRentalRate() * days\n}\n\nfunc main() {\n    car := Car{Make: \"Toyota\", Model: \"Camry\", Year: 2022}\n    truck := Truck{Make: \"Ford\", Model: \"F-150\", Year: 2021, Capacity: 1500}\n    motorcycle := Motorcycle{Make: \"Honda\", Model: \"CBR1000RR\", Year: 2023}\n\n    rentalTx := RentalTransaction{\n        Vehicle:      car,\n        StartDate:    time.Now(),\n        EndDate:      time.Now().Add(time.Hour * 24 * 5),\n        CustomerName: \"John Doe\",\n    }\n\n    fmt.Printf(\"Rented Vehicle: %s\\n\", rentalTx.Vehicle.GetDescription())\n    fmt.Printf(\"Rental Fee: $%.2f\\n\", rentalTx.CalculateRentalFee())\n\n    rentalTx.Vehicle = truck\n    rentalTx.EndDate = rentalTx.StartDate.Add(time.Hour * 24 * 3)\n    fmt.Printf(\"\\nRented Vehicle: %s\\n\", rentalTx.Vehicle.GetDescription())\n    fmt.Printf(\"Rental Fee: $%.2f\\n\", rentalTx.CalculateRentalFee())\n\n    rentalTx.Vehicle = motorcycle",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a transportation company. The company has a fleet of cars, trucks, and motorcycles. Each vehicle type has its own set of attributes and methods, but they also share some common characteristics.\n\nCreate an abstract base class called `Vehicle` with the following properties and methods:\n- `make` (string): the make of the vehicle\n- `model` (string): the model of the vehicle\n- `year` (int): the year of manufacture\n- `Start()`: a method to start the vehicle\n- `Stop()`: a method to stop the vehicle\n\nImplement the following derived classes:\n1. `Car` with additional properties:\n   - `numDoors` (int): the number of doors\n   - `numSeats` (int): the number of seats\n2. `Truck` with additional properties:\n   - `cargoCapacity` (float64): the cargo capacity in tons\n   - `towingCapacity` (float64): the towing capacity in pounds\n3. `Motorcycle` with additional properties:\n   - `engineDisplacement` (int): the engine displacement in cc\n   - `hasWindshield` (bool): indicates if the motorcycle has a windshield\n\nEach derived class should have its own implementation of the `Start()` and `Stop()` methods, as well as a method to display the vehicle's details.\n\nCreate a `TransportationCompany` struct that has a slice of `Vehicle` objects. Implement methods to add vehicles to the fleet, remove vehicles from the fleet, and display the details of all vehicles in the fleet.\n\nIn the `main()` function, create an instance of the `TransportationCompany`, add a few vehicles of each type to the fleet, and display the details of all vehicles.",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a transportation company. The company has a fleet of cars, trucks, and motorcycles. Each vehicle type has its own set of attributes and methods. Cars have a seating capacity and a method to calculate the fuel efficiency based on the distance traveled and fuel consumed. Trucks have a cargo capacity and a method to calculate the maximum load they can carry based on the cargo weight and the truck's capacity. Motorcycles have a method to calculate the time taken to reach a destination based on the distance and average speed.\n\nCreate an abstract base class called 'Vehicle' with common attributes like brand, model, and year of manufacture. Implement specific vehicle types (Car, Truck, Motorcycle) that inherit from the Vehicle class and have their own unique attributes and methods.\n\nAlso, create an interface called 'Maintainable' with a method 'getMaintenanceSchedule' that returns the maintenance schedule for a vehicle based on its age and mileage.\n\nImplement the 'Maintainable' interface for each vehicle type, considering their specific maintenance requirements.\n\nFinally, create a 'Fleet' struct that contains a slice of Vehicle objects and methods to add vehicles to the fleet, remove vehicles from the fleet, and calculate the total fuel efficiency and maintenance cost of all vehicles in the fleet.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    brand string\n    model string\n    year  int\n}\n\ntype Car struct {\n    Vehicle\n    seatingCapacity int\n}\n\nfunc (c Car) calculateFuelEfficiency(distance, fuelConsumed float64) float64 {\n    return distance / fuelConsumed\n}\n\ntype Truck struct {\n    Vehicle\n    cargoCapacity float64\n}\n\nfunc (t Truck) calculateMaxLoad(cargoWeight float64) float64 {\n    return t.cargoCapacity - cargoWeight\n}\n\ntype Motorcycle struct {\n    Vehicle\n}\n\nfunc (m Motorcycle) calculateTravelTime(distance, avgSpeed float64) float64 {\n    return distance / avgSpeed\n}\n\ntype Maintainable interface {\n    getMaintenanceSchedule(age, mileage int) string\n}\n\nfunc (c Car) getMaintenanceSchedule(age, mileage int) string {\n    return fmt.Sprintf(\"Car Maintenance: Age - %d years, Mileage - %d\", age, mileage)\n}\n\nfunc (t Truck) getMaintenanceSchedule(age, mileage int) string {\n    return fmt.Sprintf(\"Truck Maintenance: Age - %d years, Mileage - %d\", age, mileage)\n}\n\nfunc (m Motorcycle) getMaintenanceSchedule(age, mileage int) string {\n    return fmt.Sprintf(\"Motorcycle Maintenance: Age - %d years, Mileage - %d\", age, mileage)\n}\n\ntype Fleet struct {\n    vehicles []Vehicle\n}\n\nfunc (f *Fleet) addVehicle(v Vehicle) {\n    f.vehicles = append(f.vehicles, v)\n}\n\nfunc (f *Fleet) removeVehicle(v Vehicle) {\n    for i, vehicle := range f.vehicles {\n        if vehicle == v {\n            f.vehicles = append(f.vehicles[:i], f.vehicles[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (f *Fleet) calculateTotalFuelEfficiency() float64 {\n    totalFuelEfficiency := 0.0\n    for _, vehicle := range f.vehicles {\n        if car, ok := vehicle.(Car); ok {\n            totalFuelEfficiency += car.calculateFuelEfficiency(100, 8)\n        }\n    }\n    return totalFuelEfficiency\n}\n\nfunc (f *Fleet) calculateTotalMaintenanceC",
        "level": "advanced"
    },
    {
        "exercise": "Design an abstract base class called `Animal` with methods `Speak()` and `Move()`. Then create two derived classes, `Dog` and `Bird`, which inherit from `Animal` and override the `Speak()` and `Move()` methods appropriately for each animal type. The `Dog` class should have an additional method called `Fetch()`, and the `Bird` class should have an additional method called `Fly()`. Create an interface called `Pet` which includes methods `Name()` and `Play()`. Make the `Dog` class implement the `Pet` interface. In the `main()` function, create instances of `Dog` and `Bird`, and demonstrate polymorphism by calling the `Speak()` and `Move()` methods on each instance. Also create a slice of `Animal` instances and add the `Dog` and `Bird` instances to it. Iterate through the slice and call the `Speak()` method on each animal. Finally, create an instance of the `Pet` interface using a `Dog` instance, and call the `Name()` and `Play()` methods.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Animal interface {\n    Speak()\n    Move() \n}\n\ntype Dog struct {\n    name string\n}\n\nfunc (d Dog) Speak() {\n    fmt.Println(\"Woof!\")\n}\n\nfunc (d Dog) Move() {\n    fmt.Println(\"Running on four legs\")\n}\n\nfunc (d Dog) Fetch() {\n    fmt.Println(\"Fetching a ball\")\n}\n\nfunc (d Dog) Name() string {\n    return d.name\n}\n\nfunc (d Dog) Play() {\n    fmt.Println(\"Playing fetch\")\n}\n\ntype Bird struct{}\n\nfunc (b Bird) Speak() {\n    fmt.Println(\"Chirp!\")\n}\n\nfunc (b Bird) Move() {\n    fmt.Println(\"Flapping wings\")\n}\n\nfunc (b Bird) Fly() {\n    fmt.Println(\"Soaring through the sky\")\n}\n\ntype Pet interface {\n    Name() string\n    Play()\n}\n\nfunc main() {\n    dog := Dog{\"Buddy\"}\n    bird := Bird{}\n    \n    dog.Speak() \n    dog.Move()\n    dog.Fetch()\n    \n    bird.Speak()\n    bird.Move()\n    bird.Fly()\n    \n    animals := []Animal{dog, bird}\n    for _, animal := range animals {\n        animal.Speak()\n    }\n\n    var pet Pet = dog\n    fmt.Println(pet.Name()) \n    pet.Play()\n}\n```",
        "explanation": "This solution demonstrates key object-oriented programming principles in Go, including inheritance, polymorphism, and interfaces.\n\nThe `Animal` interface defines the common methods `Speak()` and `Move()` that all animal types must implement. The `Dog` and `Bird` structs represent specific animal types and provide their own implementations of these methods, allowing for polymorphism.\n\nInheritance is simulated in Go through composition, by embedding the `Animal` interface in the `Dog` and `Bird` structs. This allows `Dog` and `Bird` to inherit the methods defined in the `Animal` interface.\n\nThe `Dog` struct also implements the `Pet` interface by providing implementations for the `Name()` and `Play()` methods. This allows instances of `Dog` to be treated as `Pet` types.\n\nIn the `main()` function, instances of `Dog` and `Bird` are created, and their respective methods are called, demonstrating polymorphism. The instances are then added to a slice of `Animal` types, and the `Speak()` method is called on each animal in the slice, again showcasing polymorphism.\n\nFinally, an instance of the `Pet` interface is created using a `Dog` instance, demonstrating how interfaces can be used to define common behaviors across different types.\n\nThis design allows for extensibility and modularity, as new animal types can be easily added without modifying existing code. It also promotes code reuse and abstraction through the use of interfaces.\n\nHowever, one potential drawback is that Go does not support true inheritance like some other object-oriented languages. The composition-based approach can sometimes lead to more verbose",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of autonomous vehicles using object-oriented principles in Go. The system should handle the following functionalities:\n\n1. Vehicle registration and deregistration\n2. Vehicle status tracking (e.g., available, in-use, under maintenance)\n3. Trip assignment and tracking\n4. Battery level monitoring and recharging scheduling\n5. Vehicle software updates\n\nYour task is to create the necessary structs, interfaces, and methods to implement this system. Ensure that your design follows the SOLID principles and incorporates appropriate design patterns where applicable.",
        "answer": "```go\n// Vehicle represents an autonomous vehicle\ntype Vehicle struct {\n    ID           string\n    Status       string\n    BatteryLevel int\n    SoftwareVersion string\n}\n\n// VehicleManager is an interface for managing vehicles\ntype VehicleManager interface {\n    RegisterVehicle(vehicle *Vehicle) error\n    DeregisterVehicle(vehicleID string) error\n    UpdateVehicleStatus(vehicleID, status string) error\n    AssignTrip(vehicleID, tripID string) error\n    CompleteTrip(vehicleID, tripID string) error\n    UpdateBatteryLevel(vehicleID string, level int) error\n    ScheduleRecharge(vehicleID string) error\n    UpdateSoftware(vehicleID, version string) error\n}\n\n// Trip represents a trip assigned to a vehicle\ntype Trip struct {\n    ID         string\n    VehicleID  string\n    StartTime  time.Time\n    EndTime    time.Time\n    Completed  bool\n}\n\n// TripManager is an interface for managing trips\ntype TripManager interface {\n    CreateTrip(vehicleID string) (*Trip, error)\n    CompleteTrip(tripID string) error\n    GetTrip(tripID string) (*Trip, error)\n}\n\n// FleetManager is a struct that implements VehicleManager and TripManager\ntype FleetManager struct {\n    Vehicles map[string]*Vehicle\n    Trips    map[string]*Trip\n}\n\n// RegisterVehicle registers a new vehicle\nfunc (fm *FleetManager) RegisterVehicle(vehicle *Vehicle) error {\n    // Implement the logic to register a new vehicle\n}\n\n// DeregisterVehicle deregisters a vehicle\nfunc (fm *FleetManager) DeregisterVehicle(vehicleID string) error {\n    // Implement the logic to deregister a vehicle\n}\n\n// UpdateVehicleStatus updates the status of a vehicle\nfunc (fm *FleetManager) UpdateVehicleStatus(vehicleID, status string) error {\n    // Implement the logic to update the status of a vehicle\n}\n\n// AssignTrip assigns a trip to a vehicle\nfunc (fm *FleetManager) AssignTrip(vehicleID, tripID string) error {\n    // Implement the logic to assign a trip to a vehicle\n}\n\n// CompleteTrip marks a trip as completed\nfunc (fm *FleetManager) CompleteTrip(vehicleID, tripID string) error {\n    // Implement the logic to complete a trip\n}\n\n// UpdateBatteryLevel updates the battery level of a vehicle\nfunc (fm *FleetManager) UpdateBatteryLevel(vehicleID string, level int) error {\n    // Implement the logic to update the battery level of a vehicle\n}\n\n// ScheduleRecharge schedules a recharge for a vehicle\nfunc (fm *FleetManager) ScheduleRecharge(vehicleID string) error {\n    // Implement the logic to schedule a recharge for a vehicle\n}\n\n// UpdateSoftware updates the software version of a vehicle \nfunc (fm *FleetManager) UpdateSoftware(vehicleID, version string) error {\n    // Implement the logic to update the software version of a vehicle\n}\n\n// CreateTrip creates a new trip for a vehicle\nfunc (fm *FleetManager) CreateTrip(vehicleID string) (*Trip, error) {\n    // Implement the logic to create a new trip for a vehicle\n}\n\n// CompleteTrip marks a trip as completed\nfunc (fm *FleetManager) CompleteTrip(tripID string) error {\n    // Implement the logic to complete a trip\n}\n\n// GetTrip retrieves a trip by ID\nfunc (fm *FleetManager) Get",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system for a simplified version of Kubernetes. Your system should include the following components:\n\n1. A Pod struct that represents a group of containers running on a host. Each Pod should have a unique ID, a name, and a slice of Container objects.\n\n2. A Container struct that represents a single container within a Pod. Each Container should have a name, an image, and a slice of commands.\n\n3. A Node struct that represents a worker machine in the Kubernetes cluster. Each Node should have a unique ID, a name, a total resource capacity (e.g., CPU and memory), and a slice of Pod objects currently running on the Node.\n\n4. Implement methods for the Node struct to add and remove Pods, as well as a method to calculate the remaining resource capacity after accounting for the resource usage of all Pods running on the Node.\n\n5. Create a Scheduler interface with a single method called Schedule that takes a Pod and a slice of Node objects. The Schedule method should return the Node with the most available resource capacity to run the given Pod.\n\n6. Implement the Scheduler interface with a struct called ResourceScheduler that implements the Schedule method using a simple resource-based scheduling algorithm.\n\nYour task is to create the necessary struct definitions, method signatures, and interfaces to model this simplified Kubernetes system in Go. You should also provide a brief example usage of your system.",
        "answer": "```go\n// Pod represents a group of containers running on a host\ntype Pod struct {\n    ID         string\n    Name       string\n    Containers []Container\n}\n\n// Container represents a single container within a Pod\ntype Container struct {\n    Name     string\n    Image    string\n    Commands []string\n}\n\n// Node represents a worker machine in the Kubernetes cluster\ntype Node struct {\n    ID              string\n    Name            string\n    TotalCPU        int\n    TotalMemory     int\n    AvailableCPU    int\n    AvailableMemory int\n    Pods            []Pod\n}\n\n// AddPod adds a Pod to the Node and updates the available resources\nfunc (n *Node) AddPod(pod Pod) {\n    n.Pods = append(n.Pods, pod)\n    for _, container := range pod.Containers {\n        // Assuming each container requires 1 CPU and 100MB memory\n        n.AvailableCPU -= 1\n        n.AvailableMemory -= 100\n    }\n}\n\n// RemovePod removes a Pod from the Node and updates the available resources\nfunc (n *Node) RemovePod(pod Pod) {\n    for i, p := range n.Pods {\n        if p.ID == pod.ID {\n            n.Pods = append(n.Pods[:i], n.Pods[i+1:]...)\n            break\n        }\n    }\n    for _, container := range pod.Containers {\n        // Assuming each container requires 1 CPU and 100MB memory\n        n.AvailableCPU += 1\n        n.AvailableMemory += 100\n    }\n}\n\n// Scheduler is an interface for scheduling Pods on Nodes\ntype Scheduler interface {\n    Schedule(pod Pod, nodes []Node) Node\n}\n\n// ResourceScheduler is a simple scheduler that assigns Pods to Nodes based on available resources\ntype ResourceScheduler struct{}\n\n// Schedule implements the Scheduler interface\nfunc (rs ResourceScheduler) Schedule(pod Pod, nodes []Node) Node {\n    var bestNode Node\n    var maxAvailableResources int\n\n    for _, node := range nodes {\n        availableResources := node.AvailableCPU + node.AvailableMemory\n        if availableResources > maxAvailableResources {\n            bestNode = node\n            maxAvailableResources = availableResources\n        }\n    }\n\n    return bestNode\n}\n```\n\nExample usage:\n```go \npod := Pod{\n    ID:   ",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for modeling different types of vehicles in Go using inheritance. The system should include a base Vehicle struct with common properties and methods, and specialized structs for Cars, Trucks, and Motorcycles that inherit from Vehicle and add their own unique properties and methods.\n\nRequirements:\n- Vehicle should have properties for manufacturer, model, year, and mileage, and methods for driving and stopping. \n- Car should have additional properties for number of doors and fuel type (gas or electric).\n- Truck should have additional properties for cargo capacity (in pounds) and towing capacity. \n- Motorcycle should have an additional property for engine type (standard or electric) and a method for doing a wheelie.\n- The specialized vehicle types should inherit the drive and stop methods from Vehicle but implement them in their own way.\n\nImplement the structs and methods, and write a sample program that demonstrates creating instances of each vehicle type and calling their methods.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    manufacturer string\n    model        string\n    year         int\n    mileage      int\n}\n\nfunc (v Vehicle) drive() {\n    fmt.Printf(\"%s %s is driving\\n\", v.manufacturer, v.model)\n}\n\nfunc (v Vehicle) stop() {\n    fmt.Printf(\"%s %s has stopped\\n\", v.manufacturer, v.model)\n}\n\ntype Car struct {\n    Vehicle\n    numDoors  int\n    fuelType  string\n}\n\nfunc (c Car) drive() {\n    fmt.Printf(\"%s %s car is cruising\\n\", c.manufacturer, c.model)\n}\n\ntype Truck struct {\n    Vehicle \n    cargoCapacity int\n    towCapacity   int\n}\n\nfunc (t Truck) drive() {\n    fmt.Printf(\"%s %s truck is hauling\\n\", t.manufacturer, t.model)\n}\n\ntype Motorcycle struct {\n    Vehicle\n    engineType string\n}\n\nfunc (m Motorcycle) drive() {\n    fmt.Printf(\"%s %s motorcycle is zipping\\n\", m.manufacturer, m.model)\n}\n\nfunc (m Motorcycle) doWheely() {\n    fmt.Printf(\"%s %s motorcycle is popping a wheelie!\\n\", m.manufacturer, m.model)\n}\n\nfunc main() {\n    car := Car{\n        Vehicle: Vehicle{\n            manufacturer: \"Toyota\", \n            model:        \"Camry\",\n            year:         2020,\n            mileage:      5000,\n        },\n        numDoors: 4,\n        fuelType: \"gas\",\n    }\n    car.drive()\n    car.stop()\n\n    truck := Truck{\n        Vehicle: Vehicle{\n            manufacturer: \"Ford\",\n            model:        \"F-150\", \n            year:         2019,\n            mileage:      10000,\n        },\n        cargoCapacity: 3000,\n        towCapacity:   12000,\n    }\n    truck.drive()\n    truck.stop()\n\n    motorcycle := Motorcycle{\n        Vehicle: Vehicle{\n            manufacturer: \"Harley-Davidson\",\n            model:        \"Sportster\",\n            year:         2018, \n            mileage:      1000,\n        },\n        engineType: \"standard\",\n    }\n    motorcycle.drive()\n    motorcycle.doWheely()\n    motorcycle.stop()\n}\n```",
        "explanation": "This Go program demonstrates inheritance in object-oriented design by modeling different types of vehicles. The base Vehicle struct contains common properties like manufacturer, model, year, and mileage that all vehicles share. It also defines drive() and stop() methods with default behaviors.\n\nThe specialized vehicle structs Car, Truck, and Motorcycle embed the Vehicle struct, inheriting its properties and methods. This is Go's way of implementing inheritance. Each specialized struct can add its own unique properties, like numDoors and fuelType for Car.\n\nThe specialized structs can also override inherited methods with their own implementations. Here, each implements its own version of drive() that is specific to that vehicle type (e.g. \"cruising\" for Car vs \"zipping\" for Motorcycle). Calling drive() on a Car, Truck or Motorcycle",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a transportation company. The company has several types of vehicles, including cars, trucks, and motorcycles. Each vehicle has common properties such as make, model, year, and mileage. Cars have an additional property for the number of doors, trucks have a property for cargo capacity, and motorcycles have a property for engine displacement.\n\nCreate an object-oriented design in Go that models this vehicle management system. Your design should include base structs for common vehicle properties and specialized structs for each vehicle type that embed the base struct and add their specific properties. Implement methods for each vehicle type that calculate the remaining life of the vehicle based on its mileage and a maximum mileage constant.\n\nIn the main function, create instances of each vehicle type, set their properties, and call the remaining life methods. Print out the details and remaining life for each vehicle.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\nconst (\n\tMAX_CAR_MILES = 150000\n\tMAX_TRUCK_MILES = 300000  \n\tMAX_MOTORCYCLE_MILES = 60000\n)\n\ntype Vehicle struct {\n\tMake string\n\tModel string  \n\tYear int\n\tMileage int\n}\n\ntype Car struct {\n\tVehicle\n\tNumDoors int\n}\n\nfunc (c Car) RemainingLife() int {\n\treturn MAX_CAR_MILES - c.Mileage\n}\n\ntype Truck struct {\n\tVehicle\n\tCargoCapacity int \n}\n\nfunc (t Truck) RemainingLife() int {\n\treturn MAX_TRUCK_MILES - t.Mileage\n}\n\ntype Motorcycle struct {\n\tVehicle\n\tEngineDisplacement int\n}\n\nfunc (m Motorcycle) RemainingLife() int {\n\treturn MAX_MOTORCYCLE_MILES - m.Mileage\n}\n\nfunc main() {\n\tcar := Car{Vehicle{\"Toyota\", \"Camry\", 2018, 50000}, 4}\n\ttruck := Truck{Vehicle{\"Ford\", \"F-150\", 2015, 150000}, 1800}\n\tmotorcycle := Motorcycle{Vehicle{\"Honda\", \"CBR600\", 2020, 5000}, 599}\n\n\tfmt.Printf(\"Car: %+v, Remaining Life: %d miles\\n\", car, car.RemainingLife())\n\tfmt.Printf(\"Truck: %+v, Remaining Life: %d miles\\n\", truck, truck.RemainingLife()) \n\tfmt.Printf(\"Motorcycle: %+v, Remaining Life: %d miles\\n\", motorcycle, motorcycle.RemainingLife())\n}\n```",
        "explanation": "This design demonstrates inheritance in Go using struct embedding. The `Vehicle` struct serves as the base and contains common fields for all vehicles like make, model, year, and mileage. The `Car`, `Truck`, and `Motorcycle` structs embed `Vehicle`, inheriting its fields, and then add their own specific fields.\n\nEach specialized struct also defines a `RemainingLife` method that calculates the remaining usable miles based on the vehicle's current mileage and a constant maximum mileage defined for each vehicle type.\n\nThis design promotes code reuse through embedding while still allowing specialized behavior via methods. It organizes related data and behavior together.\n\nOne drawback is the rigid hierarchy - if a new vehicle type has very different properties it may not fit well. Go also doesn't support overriding embedded methods.\n\nAn alternative could be composition - each vehicle gets a `Vehicle` field instead of embedding, allowing more flexibility. But then common `Vehicle` fields would be accessed through the containing struct field, like `car.Vehicle.Model` instead of `car.Model`.\n\nThis exercise is considered advanced because it involves modeling a complex real-world domain and applying an",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of vehicles for a transportation company. The company has several types of vehicles, including cars, trucks, and buses. Each vehicle has a unique ID, a make, a model, and a year of manufacture. Cars have a seating capacity and a fuel type (gasoline or electric). Trucks have a cargo capacity and a maximum load weight. Buses have a seating capacity and a route number. Implement a Go program that models this system using inheritance, allowing for the creation and management of vehicles. The program should be able to: \n1. Create new vehicles of each type with the appropriate attributes. \n2. Store vehicles in a central fleet management system. \n3. Retrieve vehicle information based on the unique ID. \n4. Update vehicle attributes as needed. \n5. Perform polymorphic operations on vehicles, such as calculating the range based on the fuel type for cars or the maximum cargo weight for trucks.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    ID    int\n    Make  string\n    Model string\n    Year  int\n}\n\ntype Car struct {\n    Vehicle\n    SeatingCapacity int\n    FuelType        string\n}\n\ntype Truck struct {\n    Vehicle\n    CargoCapacity int\n    MaxLoadWeight int\n}\n\ntype Bus struct {\n    Vehicle\n    SeatingCapacity int\n    RouteNumber     string\n}\n\ntype FleetManagementSystem struct {\n    Vehicles map[int]Vehicle\n}\n\nfunc NewFleetManagementSystem() *FleetManagementSystem {\n    return &FleetManagementSystem{\n        Vehicles: make(map[int]Vehicle),\n    }\n}\n\nfunc (fms *FleetManagementSystem) AddVehicle(vehicle Vehicle) {\n    fms.Vehicles[vehicle.ID] = vehicle\n}\n\nfunc (fms *FleetManagementSystem) GetVehicle(id int) (Vehicle, bool) {\n    vehicle, found := fms.Vehicles[id]\n    return vehicle, found\n}\n\nfunc (fms *FleetManagementSystem) UpdateVehicle(vehicle Vehicle) {\n    fms.Vehicles[vehicle.ID] = vehicle\n}\n\nfunc (c *Car) Range() float64 {\n    if c.FuelType == \"electric\" {\n        return 300.0 // Example range for electric cars\n    }\n    return 500.0 // Example range for gasoline cars\n}\n\nfunc (t *Truck) MaxCargoWeight() int {\n    return t.CargoCapacity * 1000 // Example conversion from capacity to weight\n}\n\nfunc main() {\n    fms := NewFleetManagementSystem()\n\n    car := Car{\n        Vehicle:         Vehicle{ID: 1, Make: \"Tesla\", Model: \"Model 3\", Year: 2021},\n        SeatingCapacity: 5,\n        FuelType:        \"electric\",\n    }\n    fms.AddVehicle(car)\n\n    truck := Truck{\n        Vehicle:       Vehicle{ID: 2, Make: \"Ford\", Model: \"F-150\", Year: 2022},\n        CargoCapacity: 1500,\n        MaxLoadWeight: 5000,\n    }\n    fms.AddVehicle(truck)\n\n    bus := Bus{\n        Vehicle:         Vehicle{ID: 3, Make: \"Mercedes-Benz\", Model: \"Citaro\", Year: 2020},\n        SeatingCapacity: 40,\n        RouteNumber:     \"A1\",\n    }\n    fms.AddVehicle(bus)\n\n    retrievedVehicle, found := fms.GetVehicle(2)\n    if found {\n        fmt.Printf(\"Retrieved vehicle: %+v\\n\", retrieve",
        "level": "advanced"
    },
    {
        "exercise": "Design a vehicle rental system using object-oriented principles in Go. The system should support renting different types of vehicles, such as cars, trucks, and motorcycles. Each vehicle type has its own set of attributes and methods. The rental system should also manage customer information and rental transactions.\n\nRequirements:\n1. Create an abstract base struct called `Vehicle` with common attributes (e.g., make, model, year) and methods (e.g., `getRentalRate()`).\n2. Implement concrete structs for each vehicle type (`Car`, `Truck`, `Motorcycle`) that inherit from the `Vehicle` struct and add specific attributes and methods.\n3. Create a `Customer` struct to store customer information (e.g., name, contact details).\n4. Implement a `RentalTransaction` struct to manage rental details (e.g., customer, vehicle, start date, end date).\n5. Develop a `RentalSystem` struct that manages the rental process, including methods for adding vehicles, registering customers, and creating rental transactions.\n6. Ensure proper encapsulation and data privacy.\n7. Implement polymorphism by using interfaces where appropriate.\n8. Provide a main function that demonstrates the usage of the rental system.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle interface {\n    getRentalRate() float64\n}\n\ntype BaseVehicle struct {\n    make  string\n    model string\n    year  int\n}\n\ntype Car struct {\n    BaseVehicle\n    numDoors int\n}\n\nfunc (c Car) getRentalRate() float64 {\n    return 50.0\n}\n\ntype Truck struct {\n    BaseVehicle\n    cargoCapacity float64\n}\n\nfunc (t Truck) getRentalRate() float64 {\n    return 100.0\n}\n\ntype Motorcycle struct {\n    BaseVehicle\n    engineDisplacement int\n}\n\nfunc (m Motorcycle) getRentalRate() float64 {\n    return 30.0\n}\n\ntype Customer struct {\n    name    string\n    contact string\n}\n\ntype RentalTransaction struct {\n    customer Customer\n    vehicle  Vehicle\n    startDate string\n    endDate   string\n}\n\ntype RentalSystem struct {\n    vehicles   []Vehicle\n    customers  []Customer\n    rentals    []RentalTransaction\n}\n\nfunc (rs *RentalSystem) addVehicle(vehicle Vehicle) {\n    rs.vehicles = append(rs.vehicles, vehicle)\n}\n\nfunc (rs *RentalSystem) registerCustomer(customer Customer) {\n    rs.customers = append(rs.customers, customer)\n}\n\nfunc (rs *RentalSystem) createRental(customer Customer, vehicle Vehicle, startDate, endDate string) {\n    rental := RentalTransaction{\n        customer:  customer,\n        vehicle:   vehicle,\n        startDate: startDate,\n        endDate:   endDate,\n    }\n    rs.rentals = append(rs.rentals, rental)\n}\n\nfunc main() {\n    rentalSystem := RentalSystem{}\n\n    car := Car{BaseVehicle{\"Toyota\", \"Camry\", 2021}, 4}\n    truck := Truck{BaseVehicle{\"Ford\", \"F-150\", 2020}, 1500.0}\n    motorcycle := Motorcycle{BaseVehicle{\"Honda\", \"CBR\", 2022}, 600}\n\n    rentalSystem.addVehicle(car)\n    rentalSystem.addVehicle(truck)\n    rentalSystem.addVehicle(motorcycle)\n\n    customer := Customer{\"John Doe\", \"john@example.com\"}\n    rentalSystem.registerCustomer(customer)\n\n    rentalSystem.createRental(customer, car, \"2023-06-",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system for a multi-level parking lot using Golang. The parking lot should support different types of vehicles (cars, motorcycles, and buses) and have multiple floors. Each floor can have a different number of parking spots. Implement methods for parking vehicles, retrieving vehicles, and calculating parking fees based on the vehicle type and duration. Ensure proper encapsulation and use inheritance and polymorphism where appropriate.",
        "answer": "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\ntype Vehicle interface {\n    GetType() string\n    GetParkingFee(duration time.Duration) float64\n}\n\ntype Car struct{}\n\nfunc (c Car) GetType() string {\n    return \"Car\"\n}\n\nfunc (c Car) GetParkingFee(duration time.Duration) float64 {\n    return duration.Hours() * 2.5\n}\n\ntype Motorcycle struct{}\n\nfunc (m Motorcycle) GetType() string {\n    return \"Motorcycle\"\n}\n\nfunc (m Motorcycle) GetParkingFee(duration time.Duration) float64 {\n    return duration.Hours() * 1.5\n}\n\ntype Bus struct{}\n\nfunc (b Bus) GetType() string {\n    return \"Bus\"\n}\n\nfunc (b Bus) GetParkingFee(duration time.Duration) float64 {\n    return duration.Hours() * 4.0\n}\n\ntype ParkingSpot struct {\n    vehicle Vehicle\n    startTime time.Time\n}\n\ntype ParkingFloor struct {\n    spots []ParkingSpot\n}\n\nfunc (pf *ParkingFloor) ParkVehicle(vehicle Vehicle) bool {\n    for i, spot := range pf.spots {\n        if spot.vehicle == nil {\n            pf.spots[i].vehicle = vehicle\n            pf.spots[i].startTime = time.Now()\n            return true\n        }\n    }\n    return false\n}\n\nfunc (pf *ParkingFloor) RetrieveVehicle(vehicle Vehicle) (float64, bool) {\n    for i, spot := range pf.spots {\n        if spot.vehicle == vehicle {\n            duration := time.Since(spot.startTime)\n            fee := vehicle.GetParkingFee(duration)\n            pf.spots[i].vehicle = nil\n            return fee, true\n        }\n    }\n    return 0.0, false\n}\n\ntype ParkingLot struct {\n    floors []ParkingFloor\n}\n\nfunc (pl *ParkingLot) ParkVehicle(vehicle Vehicle) bool {\n    for _, floor := range pl.floors {\n        if floor.ParkVehicle(vehicle) {\n            return true\n        }\n    }\n    return false\n}\n\nfunc (pl *ParkingLot) RetrieveVehicle(vehicle Vehicle) (float64, bool) {\n    for _, floor := range pl.floors {\n        if fee, found := floor.RetrieveVehicle(vehicle); found {\n            return fee, true\n        }\n    }\n    return 0.0, false\n}\n\nfunc main() {\n    parkingLot := ParkingLot{\n        floors: []ParkingFloor{\n            {spots: make([]ParkingSpot, 10)},\n            {spots: make([]ParkingSpot, 15)},\n            {spots: make([]ParkingSpot, 20)},\n        },\n    }\n    \n    car := Car{}\n    motorcycle := Motorcycle{}\n    bus := Bus{}\n    \n    parkingLot.ParkVehicle(car)\n    parkingLot.ParkVehicle(motorcycle)\n    parkingLot.ParkVehicle(bus)\n    \n    time.Sleep(2 * time.Hour)\n    \n    fee, _ := parkingLot.RetrieveVehicle(car)\n    fmt.Printf(\"Car parking fee: $%.2f\\n\", fee)\n    \n    fee, _ = parkingLot.RetrieveVehicle(motorcycle)\n    fmt.Printf(\"Motorcycle parking fee: $%.2f\\",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system in Go to simulate a vehicle rental service. The system should support renting different types of vehicles such as cars, trucks, and motorcycles. Each vehicle type should have its own set of attributes and methods, but they should all inherit from a common Vehicle interface. The rental service should allow customers to rent vehicles, calculate rental costs based on the duration and vehicle type, and manage the availability of vehicles. Implement the necessary interfaces, structs, and methods to create a functional vehicle rental system.",
        "answer": "```go\n// Vehicle interface\ntype Vehicle interface {\n    Rent(duration int) float64\n    Return()\n    IsAvailable() bool\n}\n\n// Base vehicle struct\ntype BaseVehicle struct {\n    make  string\n    model string\n    year  int\n    price float64\n    available bool\n}\n\nfunc (v *BaseVehicle) IsAvailable() bool {\n    return v.available\n}\n\nfunc (v *BaseVehicle) Return() {\n    v.available = true\n}\n\n// Car struct\ntype Car struct {\n    BaseVehicle\n    numDoors int\n}\n\nfunc (c *Car) Rent(duration int) float64 {\n    c.available = false\n    return float64(duration) * c.price\n}\n\n// Truck struct \ntype Truck struct {\n    BaseVehicle\n    cargoCapacity float64\n}\n\nfunc (t *Truck) Rent(duration int) float64 {\n    t.available = false\n    return float64(duration) * t.price * 1.5\n}\n\n// Motorcycle struct\ntype Motorcycle struct {\n    BaseVehicle\n    engineDisplacement int\n}\n\nfunc (m *Motorcycle) Rent(duration int) float64 {\n    m.available = false\n    return float64(duration) * m.price * 0.8 \n}\n\n// Rental service\ntype RentalService struct {\n    vehicles []Vehicle\n}\n\nfunc (rs *RentalService) AddVehicle(v Vehicle) {\n    rs.vehicles = append(rs.vehicles, v)\n}\n\nfunc (rs *RentalService) RentVehicle(v Vehicle, duration int) (float64, bool) {\n    if v.IsAvailable() {\n        cost := v.Rent(duration)\n        return cost, true\n    }\n    return 0.0, false\n}\n\nfunc (rs *RentalService) ReturnVehicle(v Vehicle) {\n    v.Return()\n}\n```",
        "explanation": "This Go implementation demonstrates inheritance and polymorphism in an object-oriented vehicle rental system. The key components are:\n\n1. The `Vehicle` interface defines the common methods that all vehicle types must implement, including `Rent`, `Return`, and `IsAvailable`. This allows the rental service to treat all vehicles uniformly.\n\n2. The `BaseVehicle` struct contains common attributes shared by all vehicle types, such as make, model, year, price, and availability status. It also provides a default implementation for the `IsAvailable` and `Return` methods.\n\n3. The `Car`, `Truck`, and `Motorcycle` structs embed the `BaseVehicle` struct, inheriting its attributes and methods. Each struct can override or extend the functionality as needed. For example, the `Rent` method is overridden in each struct to apply different pricing multipliers based on the vehicle type.\n\n4. The `RentalService` struct maintains a slice of `Vehicle` interfaces, allowing it to store and manage different types of vehicles. The `AddVehicle` method adds a vehicle to the service, the `RentVehicle` method handles the rental process, and the `ReturnVehicle` method manages the return of a vehicle.\n\nBy using interfaces and struct embedding, this design achieves polymorphism, where the rental service can treat all vehicles uniformly through the `Vehicle` interface while still allowing each vehicle type to have its own specific behavior.\n\nThe design is extensible, as new vehicle types can be easily added by creating new structs that embed `BaseVehicle` and implement the `Vehicle` interface methods as needed.\n\nHowever, there are some potential drawbacks to consider:\n- The pricing logic is hardcoded within each vehicle type's `Rent` method. If the pricing rules change frequently, it might be better to extract the pricing logic",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of vehicles for a transportation company. The company has several types of vehicles, including cars, trucks, and buses. Each vehicle has common properties such as make, model, year, and mileage, but also has specific characteristics based on its type. Cars have a seating capacity, trucks have a cargo capacity, and buses have a passenger capacity. The company wants to be able to perform common operations on all vehicles, such as starting the engine, accelerating, and braking, but also perform type-specific operations like loading cargo for trucks or picking up passengers for buses. Design an object-oriented system in Go that models this vehicle fleet, ensuring proper encapsulation, inheritance, and polymorphism. Implement methods for common operations and demonstrate the usage of the system.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    make     string\n    model    string\n    year     int\n    mileage  int\n}\n\nfunc (v *Vehicle) Start() {\n    fmt.Printf(\"Starting %s %s\\n\", v.make, v.model)\n}\n\nfunc (v *Vehicle) Accelerate(speed int) {\n    fmt.Printf(\"Accelerating to %d mph\\n\", speed)\n}\n\nfunc (v *Vehicle) Brake() {\n    fmt.Println(\"Braking...\")\n}\n\ntype Car struct {\n    Vehicle\n    seatingCapacity int\n}\n\ntype Truck struct {\n    Vehicle \n    cargoCapacity int\n}\n\nfunc (t *Truck) LoadCargo(cargo int) {\n    fmt.Printf(\"Loading %d lbs of cargo\\n\", cargo)\n}\n\ntype Bus struct {\n    Vehicle\n    passengerCapacity int\n}\n\nfunc (b *Bus) PickupPassengers(passengers int) {\n    fmt.Printf(\"Picking up %d passengers\\n\", passengers)\n}\n\nfunc main() {\n    car := Car{Vehicle{\"Toyota\", \"Camry\", 2020, 5000}, 5}\n    truck := Truck{Vehicle{\"Ford\", \"F-150\", 2019, 10000}, 1500}\n    bus := Bus{Vehicle{\"Blue Bird\", \"Vision\", 2015, 50000}, 60}\n\n    car.Start()\n    car.Accelerate(60) \n    car.Brake()\n\n    truck.Start()\n    truck.LoadCargo(1000)\n    truck.Accelerate(45)\n    truck.Brake()\n\n    bus.PickupPassengers(25)\n    bus.Start() \n    bus.Accelerate(55)\n    bus.Brake()\n}\n```",
        "explanation": "The solution demonstrates inheritance by having the `Car`, `Truck`, and `Bus` types embed the `Vehicle` struct. This allows them to inherit the common fields (`make`, `model`, `year`, `mileage`) and methods (`Start()`, `Accelerate()`, `Brake()`) from the `Vehicle` type.\n\nPolymorphism is shown through the use of type-specific methods like `LoadCargo()` for trucks and `PickupPassengers()` for buses. These methods are only available on the respective types and cannot be called on a generic `Vehicle` instance.\n\nEncapsulation is maintained by keeping the fields of `Vehicle` unexported (lowercase), so they can only be accessed within the package. The types `Car`, `Truck`, and `Bus` can access these fields due to embedding `Vehicle`.\n\nThe `main()` function demonstrates creating instances of each vehicle type and calling both the common methods inherited from `Vehicle` and the type-specific methods.\n\nThis design allows for code reuse through inheritance of common properties and behaviors, while still providing flexibility for type-specific functionality. It also enables treating all vehicles polymorphically as `Vehicle` instances when needed.\n\nHowever, a potential drawback is that the embedding approach tightly couples the vehicle types to the `Vehicle` struct. If the `Vehicle` type were to change, it could impact all the embedded types. An alternative approach using interfaces could provide more flexibility and decoupling, but would require more explicit method implementations.",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system for a multi-level job scheduling system, similar to Kubernetes or Google Cloud Scheduler. The system should support defining jobs, job dependencies, scheduling policies (e.g., cron, interval), and execution environments (e.g., Docker, VMs). Implement the core components using inheritance to share common functionality among different types of jobs and execution environments. The system should allow jobs to be organized into logical groups and provide monitoring and logging capabilities.",
        "answer": "```go\n// Job represents a base job with common fields and methods\ntype Job struct {\n    Name        string\n    Description string\n    Schedule    Schedule\n    Dependencies []string\n    Executor    Executor\n}\n\nfunc (j *Job) Run() error {\n    // Common job running logic\n}\n\nfunc (j *Job) GetStatus() string {\n   // Common job status logic \n}\n\n// CronJob represents a job that runs on a cron schedule\ntype CronJob struct {\n    Job\n    CronExpression string\n}\n\n// IntervalJob represents a job that runs at fixed intervals\ntype IntervalJob struct {\n    Job\n    Interval time.Duration  \n}\n\n// Executor represents a base executor for running jobs\ntype Executor interface {\n    Execute(*Job) error\n}\n\n// DockerExecutor executes jobs in Docker containers\ntype DockerExecutor struct {\n    Client *docker.Client\n}\n\nfunc (e *DockerExecutor) Execute(job *Job) error {\n    // Logic to run job in a Docker container\n}\n\n// VMExecutor executes jobs in virtual machines\ntype VMExecutor struct {}\n\nfunc (e *VMExecutor) Execute(job *Job) error {\n    // Logic to run job in a virtual machine  \n}\n\n// Scheduler handles scheduling and running jobs\ntype Scheduler struct {\n    Jobs map[string]Job\n}\n\nfunc (s *Scheduler) AddJob(job Job) {\n    // Logic to add a job to the scheduler\n}\n\nfunc (s *Scheduler) Run() {\n    // Logic to start the scheduler and run jobs\n}\n```",
        "explanation": "The solution uses inheritance to define a base `Job` struct that contains common fields and methods shared by all jobs. Specific job types, such as `CronJob` and `IntervalJob`, embed the `Job` struct and add their own unique fields. This allows for code reuse and ensures that all jobs have access to the common functionality.\n\nThe `Executor` interface defines a contract for executing jobs, and concrete executors like `DockerExecutor` and `VMExecutor` provide different implementations for running jobs in Docker containers and virtual machines, respectively. This allows for flexibility in choosing the execution environment for each job.\n\nThe `Scheduler` acts as the central component that manages jobs and their schedules. It provides methods for adding jobs and starting the scheduler to run the jobs according to their defined schedules.\n\nBy organizing the system into logical components and using inheritance and interfaces, the code becomes more modular, extensible, and easier to maintain. It promotes code reuse, flexibility, and separation of concerns.\n\nThis design allows for further enhancements, such as adding more job types, supporting additional execution environments, implementing job monitoring and logging, and providing APIs for managing jobs and retrieving their statuses.",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a transportation company. The company has a fleet of cars, trucks, and motorcycles. Each vehicle type has its own specific attributes and methods, but they also share some common properties and behaviors.\n\nCreate an abstract base class called 'Vehicle' that contains common fields such as 'make', 'model', 'year', and 'mileage', along with methods like 'start()', 'stop()', and 'drive()'. Then, create subclasses 'Car', 'Truck', and 'Motorcycle' that inherit from the 'Vehicle' class and add their own unique attributes and methods.\n\nThe 'Car' class should have additional fields for 'numDoors' and 'fuelType', and a method called 'openTrunk()'. The 'Truck' class should have fields for 'cargoCapacity' and 'numAxles', and methods like 'loadCargo()' and 'unloadCargo()'. The 'Motorcycle' class should have fields for 'engineSize' and 'hasWindshield', and a method called 'popWheelie()'.\n\nImplement the classes and methods to showcase inheritance, method overriding, and polymorphism. Demonstrate how objects of different vehicle types can be created and how their specific and inherited methods can be called.",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of vehicles in a transportation company. The company has several types of vehicles, including cars, trucks, and buses. Each vehicle has common properties such as make, model, year, and mileage, but also has specific characteristics based on its type.\n\nRequirements:\n1. Create a base `Vehicle` struct with common fields and methods.\n2. Implement `Car`, `Truck`, and `Bus` structs that inherit from the `Vehicle` struct.\n3. Each vehicle type should have its own unique fields and methods:\n   - Cars have a `NumSeats` field and a `GetNumSeats()` method.\n   - Trucks have a `CargoCapacity` field and a `GetCargoCapacity()` method.\n   - Buses have a `MaxPassengers` field and a `GetMaxPassengers()` method.\n4. Implement a `VehicleManager` struct that maintains a list of vehicles.\n5. The `VehicleManager` should have methods to add vehicles, remove vehicles, and retrieve vehicles based on certain criteria (e.g., vehicle type, mileage range).\n6. Implement a `main()` function that demonstrates the usage of the vehicle management system.\n\nYour task is to design and implement this vehicle management system using object-oriented principles in Golang, showcasing the proper use of inheritance.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    Make    string\n    Model   string\n    Year    int\n    Mileage int\n}\n\nfunc (v *Vehicle) GetInfo() string {\n    return fmt.Sprintf(\"Make: %s, Model: %s, Year: %d, Mileage: %d\", v.Make, v.Model, v.Year, v.Mileage)\n}\n\ntype Car struct {\n    Vehicle\n    NumSeats int\n}\n\nfunc (c *Car) GetNumSeats() int {\n    return c.NumSeats\n}\n\ntype Truck struct {\n    Vehicle\n    CargoCapacity int\n}\n\nfunc (t *Truck) GetCargoCapacity() int {\n    return t.CargoCapacity\n}\n\ntype Bus struct {\n    Vehicle\n    MaxPassengers int\n}\n\nfunc (b *Bus) GetMaxPassengers() int {\n    return b.MaxPassengers\n}\n\ntype VehicleManager struct {\n    vehicles []Vehicle\n}\n\nfunc (vm *VehicleManager) AddVehicle(v Vehicle) {\n    vm.vehicles = append(vm.vehicles, v)\n}\n\nfunc (vm *VehicleManager) RemoveVehicle(index int) {\n    vm.vehicles = append(vm.vehicles[:index], vm.vehicles[index+1:]...)\n}\n\nfunc (vm *VehicleManager) GetVehiclesByType(vehicleType string) []Vehicle {\n    var result []Vehicle\n    for _, v := range vm.vehicles {\n        switch vehicleType {\n        case \"car\":\n            if _, ok := v.(*Car); ok {\n                result = append(result, v)\n            }\n        case \"truck\":\n            if _, ok := v.(*Truck); ok {\n                result = append(result, v)\n            }\n        case \"bus\":\n            if _, ok := v.(*Bus); ok {\n                result = append(result, v)\n            }\n        }\n    }\n    return result\n}\n\nfunc (vm *VehicleManager) GetVehiclesByMileageRange(min, max int) []Vehicle {\n    var result []Vehicle\n    for _, v := range vm.vehicles {\n        if v.Mileage >= min && v.Mileage <= max {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    vm := VehicleManager{}\n\n    car := &Car{Vehicle: Vehicle{Make: \"Toyota\", Model: \"Camry\", Year: 2020, Mileage: 10000}, NumSeats: 5}\n    truck := &Truck{Vehicle: Vehicle{Make: \"Ford\", Model: \"F-150\", Year: 2019, Mileage: 20000}, CargoCapacity: 1500}\n    bus :=",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system in Go to model a university registration system. The system should support different types of users (students, professors, and administrators) with varying permissions and functionality. \n\nRequirements:\n- Define base structs for User, Student, Professor, and Administrator, using composition and embedding to model inheritance relationships.\n- Implement methods for each user type to perform role-specific actions (e.g., students can register for courses, professors can grade assignments, administrators can manage user accounts).\n- Use interfaces to define common behaviors across user types (e.g., login, logout, update profile).\n- Ensure proper access control and permissions for each user type's actions.\n- Provide a way to store and retrieve user data using Go's standard library (e.g., encoding/json).\n- Create a main function that demonstrates the usage of the university registration system, including creating users, performing actions, and persisting data.",
        "answer": "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n)\n\n// User is the base struct for all user types\ntype User struct {\n\tID       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tEmail    string `json:\"email\"`\n\tPassword string `json:\"password\"`\n}\n\n// UserActions defines common actions for all users\ntype UserActions interface {\n\tLogin() bool\n\tLogout()\n\tUpdateProfile(name, email string) \n}\n\nfunc (u *User) Login() bool {\n\t// Implement login logic here\n\treturn true\n}\n\nfunc (u *User) Logout() {\n\t// Implement logout logic here\n}\n\nfunc (u *User) UpdateProfile(name, email string) {\n\tu.Name = name\n\tu.Email = email\n}\n\n// Student represents a student user\ntype Student struct {\n\tUser\n\tCourses []string `json:\"courses\"`\n}\n\nfunc (s *Student) RegisterCourse(course string) {\n\ts.Courses = append(s.Courses, course)\n}\n\n// Professor represents a professor user \ntype Professor struct {\n\tUser\n\tCourses []string `json:\"courses\"`\n}\n\nfunc (p *Professor) GradeAssignment(student, course string, grade int) {\n\t// Implement grading logic here\n}\n\n// Administrator represents an admin user\ntype Administrator struct {\n\tUser\n}\n\nfunc (a *Administrator) ManageUser(user User) {\n\t// Implement user management logic here  \n}\n\nfunc main() {\n\t// Create users\n\tstudent := &Student{\n\t\tUser: User{ID: 1, Name: \"Alice\", Email: \"alice@example.com\", Password: \"password\"},\n\t}\n\n\tprofessor := &Professor{ \n\t\tUser: User{ID: 2, Name: \"Bob\", Email: \"bob@example.com\", Password: \"password\"},\n\t}\n\n\tadmin := &Administrator{\n\t\tUser: User{ID: 3, Name: \"Charlie\", Email: \"charlie@example.com\", Password: \"password\"},\n\t}\n\n\t// Perform actions\n\tstudent.Login()\n\tstudent.RegisterCourse(\"Math\")\n\tstudent.RegisterCourse(\"Physics\")\n\n\tprofessor.Login()\n\tprofessor.UpdateProfile(\"Dr. Bob\", professor.Email)\n\tprofessor.GradeAssignment(\"Alice\", \"Math\", 95)\n\n\tadmin.Login()\n\tadmin.ManageUser(*student)\n\n\t// Persist data\n\tdata, _ := json.MarshalIndent(student, \"\", \"  \") \n\t_ = ioutil.WriteFile(\"student.json\", data, 0644)\n\n\t// Output\n\tfmt.Println(\"University Registration System Demo Complete\")\n}\n```",
        "explanation": "The provided solution demonstrates an object-oriented design for a university registration system in Go, focusing on inheritance using composition and embedding.\n\nThe `User` struct serves as the base for all user types, containing common fields like `ID`, `Name`, `Email`, and `Password`. The `UserActions` interface defines common behaviors for all users, such as `Login()`, `Logout()`, and `UpdateProfile()`. The `User",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a library using object-oriented principles in Go. The library should allow users to borrow and return books, and the librarian should be able to add and remove books from the library's collection. Implement the following:\n\n1. Define structs for `Book`, `User`, and `Librarian` with appropriate fields and methods.\n2. Implement methods for borrowing and returning books by users.\n3. Implement methods for adding and removing books by the librarian.\n4. Ensure proper encapsulation and access control for the structs and their methods.\n5. Demonstrate the usage of the library system with sample code.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Book struct {\n    title  string\n    author string\n    isBorrowed bool\n}\n\nfunc (b *Book) borrowBook() {\n    b.isBorrowed = true\n}\n\nfunc (b *Book) returnBook() {\n    b.isBorrowed = false\n}\n\ntype User struct {\n    name string\n    borrowedBooks []*Book\n}\n\nfunc (u *User) borrowBook(book *Book) {\n    if !book.isBorrowed {\n        book.borrowBook()\n        u.borrowedBooks = append(u.borrowedBooks, book)\n        fmt.Printf(\"%s has borrowed the book '%s'\\n\", u.name, book.title)\n    } else {\n        fmt.Printf(\"The book '%s' is already borrowed\\n\", book.title)\n    }\n}\n\nfunc (u *User) returnBook(book *Book) {\n    for i, b := range u.borrowedBooks {\n        if b == book {\n            book.returnBook()\n            u.borrowedBooks = append(u.borrowedBooks[:i], u.borrowedBooks[i+1:]...)\n            fmt.Printf(\"%s has returned the book '%s'\\n\", u.name, book.title)\n            return\n        }\n    }\n    fmt.Printf(\"%s has not borrowed the book '%s'\\n\", u.name, book.title)\n}\n\ntype Librarian struct {\n    name string\n}\n\nfunc (l *Librarian) addBook(book *Book, library *Library) {\n    library.books = append(library.books, book)\n    fmt.Printf(\"Librarian %s has added the book '%s' to the library\\n\", l.name, book.title)\n}\n\nfunc (l *Librarian) removeBook(book *Book, library *Library) {\n    for i, b := range library.books {\n        if b == book {\n            library.books = append(library.books[:i], library.books[i+1:]...)\n            fmt.Printf(\"Librarian %s has removed the book '%s' from the library\\n\", l.name, book.title)\n            return\n        }\n    }\n    fmt.Printf(\"The book '%s' is not found in the library\\n\", book.title)\n}\n\ntype Library struct {\n    books []*Book\n}\n\nfunc main() {\n    library := &Library{}\n\n    book1 := &Book{title: \"Book 1\", author: \"Author 1\"}\n    book2 := &Book{title: \"Book 2\", author: \"Author 2\"}\n\n    user := &User{name: \"John\"}\n    librarian := &Librarian{name: \"Alice\"}\n\n    librarian.addBook(book1, library)\n    librarian.addBook(book2, library)\n\n    user.borrowBook(book1)\n    user.borrowBook(book2)\n    user.returnBook(book1)\n\n    librarian.removeBook(book2, library)\n}\n```",
        "explanation": "The provided solution demonstrates the implementation of a library management system using object-oriented principles in Go. Here's a breakdown of the key concepts and design choices:\n\n1. Structs: The solution defines three main structs: `Book`, `User`, and `Librarian`. Each struct encapsulates the relevant data and behavior for each entity in the library system.\n\n2. Encapsulation: The fields of the structs are kept private (lowercase) to ensure proper encaps",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a library's book collection using object-oriented principles in Go. The system should support the following functionalities:\n\n1. Add new books to the library's collection.\n2. Remove books from the collection.\n3. Search for books by title, author, or ISBN.\n4. Assign books to library members for borrowing.\n5. Return borrowed books.\n6. Calculate late fees for overdue books.\n\nImplement the necessary structs, interfaces, and methods to achieve these functionalities. Ensure proper encapsulation and use of inheritance where applicable.",
        "answer": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Book struct {\n\tTitle  string\n\tAuthor string\n\tISBN   string\n}\n\ntype LibraryMember struct {\n\tName  string\n\tID    int\n\tBooks []*Book\n}\n\ntype Library struct {\n\tBooks   []*Book\n\tMembers []*LibraryMember\n}\n\nfunc (l *Library) AddBook(book *Book) {\n\tl.Books = append(l.Books, book)\n}\n\nfunc (l *Library) RemoveBook(isbn string) error {\n\tfor i, book := range l.Books {\n\t\tif book.ISBN == isbn {\n\t\t\tl.Books = append(l.Books[:i], l.Books[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"book not found\")\n}\n\nfunc (l *Library) SearchBooks(query string) []*Book {\n\tvar results []*Book\n\tfor _, book := range l.Books {\n\t\tif book.Title == query || book.Author == query || book.ISBN == query {\n\t\t\tresults = append(results, book)\n\t\t}\n\t}\n\treturn results\n}\n\nfunc (l *Library) AssignBook(memberID int, isbn string) error {\n\tbook, err := l.findBookByISBN(isbn)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmember, err := l.findMemberByID(memberID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmember.Books = append(member.Books, book)\n\treturn nil\n}\n\nfunc (l *Library) ReturnBook(memberID int, isbn string) error {\n\tmember, err := l.findMemberByID(memberID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor i, book := range member.Books {\n\t\tif book.ISBN == isbn {\n\t\t\tmember.Books = append(member.Books[:i], member.Books[i+1:]...)\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn errors.New(\"book not found\")\n}\n\nfunc (l *Library) CalculateLateFees(memberID int, isbn string, daysLate int) float64 {\n\tconst feePerDay = 0.50\n\treturn float64(daysLate) * feePerDay\n}\n\nfunc (l *Library) findBookByISBN(isbn string) (*Book, error) {\n\tfor _, book := range l.Books {\n\t\tif book.ISBN == isbn {\n\t\t\treturn book, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"book not found\")\n}\n\nfunc (l *Library) findMemberByID(id int) (*LibraryMember, error) {\n\tfor",
        "level": "advanced"
    },
    {
        "exercise": "Design a flexible and extensible system for managing different types of vehicles in a car rental service. The system should allow for the creation of various vehicle types (e.g., cars, trucks, motorcycles) with their specific attributes and behaviors. Implement the following:\n\n1. Define an interface called `Vehicle` with methods `Rent()`, `Return()`, and `GetInfo()`. \n2. Create struct types `Car`, `Truck`, and `Motorcycle` that implement the `Vehicle` interface.\n3. Each vehicle type should have its own unique attributes (e.g., brand, model, year, rent price per day).\n4. Implement a `VehicleManager` struct that keeps track of a list of available vehicles and provides methods to add vehicles, remove vehicles, and get vehicle info by ID.\n5. Demonstrate the usage of the `VehicleManager` by adding different types of vehicles, renting a vehicle, and returning a vehicle.",
        "answer": "```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Vehicle interface {\n\tRent()\n\tReturn()\n\tGetInfo() string\n}\n\ntype Car struct {\n\tID         int\n\tBrand      string\n\tModel      string\n\tYear       int\n\tRentPrice  float64\n\tIsRented   bool\n}\n\nfunc (c *Car) Rent() {\n\tc.IsRented = true\n}\n\nfunc (c *Car) Return() {\n\tc.IsRented = false\n}\n\nfunc (c *Car) GetInfo() string {\n\treturn fmt.Sprintf(\"Car: %s %s (%d) - Rent Price: $%.2f\", c.Brand, c.Model, c.Year, c.RentPrice)\n}\n\ntype Truck struct {\n\tID         int\n\tBrand      string\n\tModel      string\n\tYear       int\n\tRentPrice  float64\n\tIsRented   bool\n\tCargoSpace float64\n}\n\nfunc (t *Truck) Rent() {\n\tt.IsRented = true\n}\n\nfunc (t *Truck) Return() {\n\tt.IsRented = false\n}\n\nfunc (t *Truck) GetInfo() string {\n\treturn fmt.Sprintf(\"Truck: %s %s (%d) - Rent Price: $%.2f, Cargo Space: %.2f m\u00b3\", t.Brand, t.Model, t.Year, t.RentPrice, t.CargoSpace)\n}\n\ntype Motorcycle struct {\n\tID         int\n\tBrand      string\n\tModel      string\n\tYear       int\n\tRentPrice  float64\n\tIsRented   bool\n\tEngineSize int\n}\n\nfunc (m *Motorcycle) Rent() {\n\tm.IsRented = true\n}\n\nfunc (m *Motorcycle) Return() {\n\tm.IsRented = false\n}\n\nfunc (m *Motorcycle) GetInfo() string {\n\treturn fmt.Sprintf(\"Motorcycle: %s %s (%d) - Rent Price: $%.2f, Engine Size: %d cc\", m.Brand, m.Model, m.Year, m.RentPrice, m.EngineSize)\n}\n\ntype VehicleManager struct {\n\tVehicles []Vehicle\n}\n\nfunc (vm *VehicleManager) AddVehicle(v Vehicle) {\n\tvm.Vehicles = append(vm.Vehicles, v)\n}\n\nfunc (vm *VehicleManager) RemoveVehicle(id int) {\n\tfor i, v := range vm.Vehicles {\n\t\tswitch vehicle := v.(type) {\n\t\tcase *Car:\n\t\t\tif vehicle",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system in Go to model a university. The system should have the following types: University, Department, Course, Professor, and Student. \n\nThe University type should contain a list of Departments. Each Department should have a list of Courses and Professors. Each Course should have a list of enrolled Students and a Professor teaching it. Professors and Students should have appropriate attributes like name, ID, etc.\n\nImplement methods for the following functionalities:\n1. Allow a Student to enroll in a Course.\n2. Allow a Professor to be assigned to a Course.\n3. Calculate the total number of Students in a Department.\n4. Calculate the total number of Courses a Student is enrolled in.\n5. Find the Professor teaching the most Courses in a Department.\n\nEnsure proper encapsulation and minimize duplication of code by utilizing object-oriented principles like inheritance and composition where appropriate.",
        "answer": "```go\ntype University struct {\n\tname string\n\tdepartments []*Department\n}\n\ntype Department struct {\n\tname string\n\tcourses []*Course\n\tprofessors []*Professor\n}\n\ntype Course struct {\n\tname string\n\tcode string\n\tprofessor *Professor\n\tstudents []*Student\n}\n\ntype Professor struct {\n\tname string\n\tid int\n\tcourses []*Course\n}\n\ntype Student struct {\n\tname string\n\tid int\n\tcourses []*Course\n}\n\nfunc (c *Course) addStudent(s *Student) {\n\tc.students = append(c.students, s)\n\ts.courses = append(s.courses, c)\n}\n\nfunc (c *Course) assignProfessor(p *Professor) {\n\tc.professor = p\n\tp.courses = append(p.courses, c)\n}\n\nfunc (d *Department) getTotalStudents() int {\n\ttotal := 0\n\tfor _, c := range d.courses {\n\t\ttotal += len(c.students)\n\t}\n\treturn total\n}\n\nfunc (s *Student) getTotalCourses() int {\n\treturn len(s.courses)\n}\n\nfunc (d *Department) getProfessorWithMostCourses() *Professor {\n\tvar profWithMostCourses *Professor\n\tmaxCourses := 0\n\tfor _, p := range d.professors {\n\t\tif len(p.courses) > maxCourses {\n\t\t\tmaxCourses = len(p.courses)\n\t\t\tprofWithMostCourses = p\n\t\t}\n\t}\n\treturn profWithMostCourses\n}\n```",
        "explanation": "The solution models the university system using structs and slices to represent the relationships between entities. The `University` struct contains a slice of `Department` pointers. Each `Department` has slices of `Course` and `Professor` pointers. The `Course` struct holds a pointer to the `Professor` teaching it and a slice of enrolled `Student` pointers. Both `Professor` and `Student` structs maintain slices of the `Course` pointers they are associated with.\n\nThe `addStudent` method on the `Course` type allows bi-directional enrollment by appending the `Student` to the `Course`'s student list and appending the `Course` to the `Student`'s course list. Similarly, the `assignProfessor` method establishes the teaching relationship between a `Course` and a `Professor`.\n\nThe `getTotalStudents` method on the `Department` type iterates through its courses and sums up the number of students in each course. The `getTotalCourses` method on the `Student` type simply returns the length of the student's course slice.\n\nTo find the professor teaching the most courses in a department, the `getProfessorWithMostCourses` method iterates through the department's professors, keeps",
        "level": "advanced"
    },
    {
        "exercise": "Design a flexible and extensible system for managing a fleet of vehicles in a transportation company. The system should support different types of vehicles (e.g., cars, trucks, buses) and allow for easy addition of new vehicle types in the future. Each vehicle should have properties such as make, model, year, and license plate number. The system should also track the current status of each vehicle (e.g., available, in use, under maintenance).\n\nImplement the following:\n1. Define an interface called `Vehicle` with methods common to all vehicles, such as `getMake()`, `getModel()`, `getYear()`, `getLicensePlate()`, and `getStatus()`.\n2. Create concrete classes for each vehicle type (e.g., `Car`, `Truck`, `Bus`) that implement the `Vehicle` interface and add any additional properties or methods specific to each type.\n3. Implement a `VehicleManager` struct that maintains a collection of vehicles and provides methods to add, remove, and update vehicles, as well as search for vehicles based on various criteria.\n4. Demonstrate the usage of the vehicle management system by creating instances of different vehicle types, adding them to the `VehicleManager`, and performing operations like searching for vehicles based on specific criteria and updating vehicle status.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype VehicleStatus int\n\nconst (\n\tAvailable VehicleStatus = iota\n\tInUse\n\tUnderMaintenance\n)\n\ntype Vehicle interface {\n\tgetMake() string\n\tgetModel() string\n\tgetYear() int\n\tgetLicensePlate() string\n\tgetStatus() VehicleStatus\n\tsetStatus(VehicleStatus)\n}\n\ntype Car struct {\n\tMake         string\n\tModel        string\n\tYear         int\n\tLicensePlate string\n\tStatus       VehicleStatus\n}\n\nfunc (c Car) getMake() string                 { return c.Make }\nfunc (c Car) getModel() string                { return c.Model }\nfunc (c Car) getYear() int                    { return c.Year }\nfunc (c Car) getLicensePlate() string         { return c.LicensePlate }\nfunc (c Car) getStatus() VehicleStatus        { return c.Status }\nfunc (c *Car) setStatus(status VehicleStatus) { c.Status = status }\n\ntype Truck struct {\n\tMake         string\n\tModel        string\n\tYear         int\n\tLicensePlate string\n\tStatus       VehicleStatus\n\tCargoCapacity int\n}\n\nfunc (t Truck) getMake() string                 { return t.Make }\nfunc (t Truck) getModel() string                { return t.Model }\nfunc (t Truck) getYear() int                    { return t.Year }\nfunc (t Truck) getLicensePlate() string         { return t.LicensePlate }\nfunc (t Truck) getStatus() VehicleStatus        { return t.Status }\nfunc (t *Truck) setStatus(status VehicleStatus) { t.Status = status }\n\ntype Bus struct {\n\tMake         string\n\tModel        string\n\tYear         int\n\tLicensePlate string\n\tStatus       VehicleStatus\n\tPassengerCapacity int\n}\n\nfunc (b Bus) getMake() string                 { return b.Make }\nfunc (b Bus) getModel() string                { return b.Model }\nfunc (b Bus) getYear() int                    { return b.Year }\nfunc (b Bus) getLicensePlate() string         { return b.LicensePlate }\nfunc (b Bus) getStatus() VehicleStatus        { return b.Status }\nfunc (b *Bus) setStatus(status VehicleStatus) { b",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system for a vehicle rental service. The system should support renting different types of vehicles, such as cars, trucks, and motorcycles. Each vehicle type has its own set of attributes and methods. Implement the following:\n\n1. Define an interface named `Vehicle` with methods `getRentalRate() float64` and `getType() string`.\n\n2. Create structs `Car`, `Truck`, and `Motorcycle` that implement the `Vehicle` interface. Each struct should have its own unique attributes and implement the interface methods appropriately.\n\n3. Define a `VehicleRental` struct that has a slice of `Vehicle` objects called `inventory`.\n\n4. Implement a method `addVehicle(v Vehicle)` for the `VehicleRental` struct to add a vehicle to the inventory.\n\n5. Implement a method `rentVehicle(vehicleType string) (Vehicle, error)` for the `VehicleRental` struct that finds the first available vehicle of the specified type, removes it from the inventory, and returns it. If no vehicle of the specified type is available, return an error.\n\n6. Implement a method `returnVehicle(v Vehicle)` for the `VehicleRental` struct that adds the returned vehicle back to the inventory.",
        "answer": "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Vehicle interface {\n\tgetRentalRate() float64\n\tgetType() string\n}\n\ntype Car struct {\n\tmake  string\n\tmodel string\n\tprice float64\n}\n\nfunc (c Car) getRentalRate() float64 {\n\treturn c.price\n}\n\nfunc (c Car) getType() string {\n\treturn \"car\"\n}\n\ntype Truck struct {\n\tmake     string\n\tmodel    string\n\tcapacity int\n\tprice    float64\n}\n\nfunc (t Truck) getRentalRate() float64 {\n\treturn t.price\n}\n\nfunc (t Truck) getType() string {\n\treturn \"truck\"\n}\n\ntype Motorcycle struct {\n\tmake  string\n\tmodel string\n\tprice float64\n}\n\nfunc (m Motorcycle) getRentalRate() float64 {\n\treturn m.price\n}\n\nfunc (m Motorcycle) getType() string {\n\treturn \"motorcycle\"\n}\n\ntype VehicleRental struct {\n\tinventory []Vehicle\n}\n\nfunc (vr *VehicleRental) addVehicle(v Vehicle) {\n\tvr.inventory = append(vr.inventory, v)\n}\n\nfunc (vr *VehicleRental) rentVehicle(vehicleType string) (Vehicle, error) {\n\tfor i, v := range vr.inventory {\n\t\tif v.getType() == vehicleType {\n\t\t\tvr.inventory = append(vr.inventory[:i], vr.inventory[i+1:]...)\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn nil, errors.New(\"no available vehicle of type \" + vehicleType)\n}\n\nfunc (vr *VehicleRental) returnVehicle(v Vehicle) {\n\tvr.inventory = append(vr.inventory, v)\n}\n\nfunc main() {\n\trental := &VehicleRental{}\n\n\tcar := Car{\"Toyota\", \"Camry\", 50.0}\n\ttruck := Truck{\"Ford\", \"F-150\", 1500, 100.0}\n\tmotorcycle := Motorcycle{\"Honda\", \"CBR\", 30.0}\n\n\trental.addVehicle(car)\n\trental",
        "level": "advanced"
    },
    {
        "exercise": "Design a banking system using object-oriented programming principles in Go. The system should have the following features:\n\n1. Three types of accounts: Savings, Checking, and Credit.\n2. Each account should have common properties like account number, balance, and account holder name.\n3. Each account type should have specific methods:\n   - Savings: Deposit, Withdraw, and CalculateInterest\n   - Checking: Deposit, Withdraw, and Deduct (for fees)\n   - Credit: Deposit, Withdraw, and CalculateInterest (different from Savings)\n4. Implement an interface called 'Account' with common methods like Deposit and Withdraw.\n5. Create a 'Bank' struct that manages a collection of accounts.\n6. The 'Bank' struct should have methods to:\n   - Add an account\n   - Remove an account\n   - Find an account by account number\n   - Apply interest to all savings and credit accounts\n   - Deduct fees from all checking accounts\n7. Ensure proper encapsulation and inheritance are used when designing the system.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Account interface {\n    Deposit(amount float64)\n    Withdraw(amount float64) error\n    String() string\n}\n\ntype baseAccount struct {\n    accountNumber int\n    balance       float64\n    holderName    string\n}\n\nfunc (a *baseAccount) Deposit(amount float64) {\n    a.balance += amount\n}\n\nfunc (a *baseAccount) Withdraw(amount float64) error {\n    if a.balance < amount {\n        return fmt.Errorf(\"insufficient balance\")\n    }\n    a.balance -= amount\n    return nil\n}\n\ntype SavingsAccount struct {\n    baseAccount\n    interestRate float64\n}\n\nfunc (sa *SavingsAccount) CalculateInterest() {\n    sa.balance += sa.balance * sa.interestRate\n}\n\nfunc (sa *SavingsAccount) String() string {\n    return fmt.Sprintf(\"Savings Account #%d - Balance: $%.2f\", sa.accountNumber, sa.balance)\n}\n\ntype CheckingAccount struct {\n    baseAccount\n}\n\nfunc (ca *CheckingAccount) Deduct(amount float64) {\n    ca.balance -= amount\n}\n\nfunc (ca *CheckingAccount) String() string {\n    return fmt.Sprintf(\"Checking Account #%d - Balance: $%.2f\", ca.accountNumber, ca.balance)\n}\n\ntype CreditAccount struct {\n    baseAccount\n    creditLimit  float64\n    interestRate float64\n}\n\nfunc (ca *CreditAccount) Withdraw(amount float64) error {\n    if ca.balance+ca.creditLimit < amount {\n        return fmt.Errorf(\"credit limit exceeded\")\n    }\n    ca.balance -= amount\n    return nil\n}\n\nfunc (ca *CreditAccount) CalculateInterest() {\n    if ca.balance < 0 {\n        ca.balance += ca.balance * ca.interestRate\n    }\n}\n\nfunc (ca *CreditAccount) String() string {\n    return fmt.Sprintf(\"Credit Account #%d - Balance: $%.2f - Credit Limit: $%.2f\", ca.accountNumber, ca.balance, ca.creditLimit)\n}\n\ntype Bank struct {\n    accounts []Account\n}\n\nfunc (b *Bank) AddAccount(account Account) {\n    b.accounts = append(b.accounts, account)\n}\n\nfunc (b *Bank) RemoveAccount(accountNumber int) {\n    for i, account := range b.accounts {\n        if account.(*baseAccount).accountNumber == accountNumber {\n            b.accounts = append(b.accounts[:i], b.accounts[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (b *Bank) FindAccount(accountNumber int) Account {\n    for _, account := range b.accounts {\n        if account.(*baseAccount).accountNumber == accountNumber {\n            return account\n        }\n    }\n    return nil\n}\n\nfunc (b *Bank) ApplyInterest() {\n    for _, account := range b.accounts {\n        if sa",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of autonomous vehicles for a ride-sharing service. The system should handle the following tasks:\n\n1. Efficiently match passengers with available vehicles based on location, capacity, and estimated time of arrival.\n2. Optimize routes for each vehicle to minimize travel time and fuel consumption.\n3. Monitor the status and health of each vehicle, including battery level, sensor data, and maintenance needs.\n4. Handle unexpected events such as vehicle malfunctions, traffic congestion, and passenger cancellations.\n5. Implement a payment system that tracks fares, processes transactions, and distributes earnings to vehicle owners.\n\nYour design should demonstrate the use of inheritance, polymorphism, and encapsulation. Provide class definitions, method signatures, and a brief description of how the system components interact.",
        "answer": "```go\n// Vehicle represents a generic autonomous vehicle\ntype Vehicle struct {\n    ID            string\n    Location      Location\n    Capacity      int\n    Status        string\n    Battery       float64\n    MaintenanceRequests []Maintenance \n}\n\nfunc (v *Vehicle) UpdateLocation(newLocation Location) {\n  // Update vehicle location\n}\n\nfunc (v *Vehicle) CheckBatteryLevel() float64 { \n  // Check current battery level\n}\n\n// ElectricVehicle inherits from Vehicle and adds charging specific methods \ntype ElectricVehicle struct {\n    Vehicle\n    ChargeRate float64\n}\n\nfunc (ev *ElectricVehicle) ChargeBattery(amount float64) {\n  // Charge the vehicle's battery\n}\n\n// Passenger represents a user requesting a ride\ntype Passenger struct {\n    ID       string \n    Location Location\n}\n\n// Trip represents a passenger's trip with a vehicle\ntype Trip struct {\n    ID            string\n    Passenger     Passenger \n    Vehicle       Vehicle\n    PickupLocation Location\n    DropoffLocation Location \n    StartTime     time.Time\n    EndTime       time.Time\n    Fare          float64\n    Status        string  \n}\n\n// RideShareService manages the fleet of vehicles and passenger trips\ntype RideShareService struct {\n    Vehicles     []Vehicle\n    Passengers   []Passenger\n    Trips        []Trip\n    PaymentProcessor PaymentProcessor\n}\n\nfunc (rs *RideShareService) MatchVehicleToPassenger(p Passenger) Vehicle {\n  // Match passenger to optimal available vehicle based on location, capacity, ETA \n}\n\nfunc (rs *RideShareService) OptimizeRoute(t Trip) {\n  // Optimize vehicle's route based on traffic, distance, fuel/energy efficiency\n}\n\nfunc (rs *RideShareService) MonitorVehicleHealth() {\n  // Monitor status and schedule maintenance for vehicles \n}\n\nfunc (rs *RideShareService) HandleUnexpectedEvent(event Event) {\n  // Gracefully handle vehicle, traffic, passenger issues\n}\n\n// PaymentProcessor handles billing and payments\ntype PaymentProcessor interface {\n    ProcessFare(trip Trip) \n    DistributeEarnings()\n}\n\n// StripePaymentProcessor implements payment processing with Stripe\ntype StripePaymentProcessor struct{}\n\nfunc (p StripePaymentProcessor) ProcessFare(trip Trip) {\n  // Process fare using Stripe API \n}\n```",
        "explanation": "This design uses object-oriented principles to create a modular, extensible system for managing an autonomous ride-sharing fleet.\n\nThe `Vehicle` struct represents a generic vehicle with common properties and methods. The `ElectricVehicle` type inherits from `Vehicle` and adds electric charging functionality, demonstrating inheritance and polymorphism. This allows the fleet to consist of different vehicle types with shared core functionality.\n\nThe `Passenger` and `Trip` structs model the users and their requested rides. The `RideShareService` encapsulates the core business logic, keeping the passenger, trip and vehicle data internal to the service.  It provides methods for matching passengers to vehicles, optimizing routes, monitoring vehicle health, and handling unexpected events.  These methods abstract the complex logic and interactions between components.\n\nThe `PaymentProcessor` interface defines the contract for processing fares and distributing earnings. The `StripePaymentProcessor` implements this interface, allowing the payment processing to be swapped out with alternative implementations as needed. This demonstrates the use of interfaces for abstraction and flexibility.",
        "level": "advanced"
    },
    {
        "exercise": "Design and implement a generic graph data structure in Go that supports both directed and undirected graphs. The graph should allow adding and removing vertices and edges, as well as performing basic graph operations such as depth-first search (DFS) and breadth-first search (BFS). Vertices should be represented by a generic type, allowing the graph to store any type of data. Implement the graph using an adjacency list representation.\n\nProvide the following:\n1. The necessary type definitions for the graph, vertices, and edges.\n2. Methods for adding and removing vertices and edges.\n3. Methods for performing DFS and BFS traversals on the graph, starting from a given vertex.\n4. An example usage of the graph, demonstrating its functionality.",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a transportation company. The company has cars, trucks, and motorcycles. Each vehicle type has its own properties and methods, but they also share some common attributes and behaviors.\n\nCreate an abstract base class called 'Vehicle' with the following properties and methods:\n- 'manufactureYear' (int): The year the vehicle was manufactured\n- 'getManufactureYear()': Returns the manufacture year\n- 'startEngine()': An abstract method to start the vehicle's engine\n\nCreate three classes that inherit from 'Vehicle':\n1. 'Car' with additional properties: 'numDoors' (int), 'numPassengers' (int), and a method 'startEngine()' that prints \"Starting car engine\".\n2. 'Truck' with additional properties: 'cargoCapacity' (float64), 'towingCapacity' (float64), and a method 'startEngine()' that prints \"Starting truck engine\".\n3. 'Motorcycle' with an additional property: 'hasWindscreen' (bool), and a method 'startEngine()' that prints \"Starting motorcycle engine\".\n\nCreate a 'TransportationCompany' struct with a 'vehicles' property that is a slice of 'Vehicle'. Implement methods to add vehicles to the company and start all vehicle engines.\n\nDemonstrate the usage of the system by creating instances of each vehicle type, adding them to the transportation company, and starting all engines.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle interface {\n    getManufactureYear() int\n    startEngine()\n}\n\ntype vehicleBase struct {\n    manufactureYear int\n}\n\nfunc (v *vehicleBase) getManufactureYear() int {\n    return v.manufactureYear\n}\n\ntype Car struct {\n    vehicleBase\n    numDoors int\n    numPassengers int \n}\n\nfunc (c *Car) startEngine() {\n    fmt.Println(\"Starting car engine\")\n}\n\ntype Truck struct {\n    vehicleBase\n    cargoCapacity float64\n    towingCapacity float64\n}\n\nfunc (t *Truck) startEngine() {\n    fmt.Println(\"Starting truck engine\")\n}\n\ntype Motorcycle struct {\n    vehicleBase\n    hasWindscreen bool\n}\n\nfunc (m *Motorcycle) startEngine() {\n    fmt.Println(\"Starting motorcycle engine\")\n}\n\ntype TransportationCompany struct {\n    vehicles []Vehicle\n}\n\nfunc (tc *TransportationCompany) addVehicle(v Vehicle) {\n    tc.vehicles = append(tc.vehicles, v)\n}\n\nfunc (tc *TransportationCompany) startAllEngines() {\n    for _, v := range tc.vehicles {\n        v.startEngine()\n    }\n}\n\nfunc main() {\n    company := TransportationCompany{}\n\n    car := &Car{vehicleBase{2022}, 4, 5}\n    truck := &Truck{vehicleBase{2021}, 10000.0, 5000.0}\n    motorcycle := &Motorcycle{vehicleBase{2023}, true}\n\n    company.addVehicle(car)\n    company.addVehicle(truck)\n    company.addVehicle(motorcycle)\n\n    company.startAllEngines()\n}\n```",
        "explanation": "The solution demonstrates the use of inheritance in Go using interfaces and composition. The 'Vehicle' interface defines the common methods that all vehicles must implement, while the 'vehicleBase' struct contains the shared 'manufactureYear' property.\n\nThe 'Car', 'Truck', and 'Motorcycle' structs embed the 'vehicleBase' struct to inherit the 'manufactureYear' property and the 'getManufactureYear()' method. Each vehicle type also implements its own version of the",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a transportation company. The company has a fleet of cars, trucks, and motorcycles. Each vehicle type has its own specific attributes and methods, but they all share some common properties such as make, model, year, and mileage. The cars have additional properties like the number of doors and fuel type. Trucks have extra attributes like cargo capacity and towing capacity. Motorcycles have properties like engine displacement and number of cylinders. Implement a base Vehicle struct and derived structs for Car, Truck, and Motorcycle. Create methods for each vehicle type to calculate the estimated fuel consumption based on the mileage and vehicle-specific factors. Also, implement a method for the transportation company to calculate the total fuel consumption of all vehicles in its fleet.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    make     string\n    model    string\n    year     int\n    mileage  float64\n}\n\nfunc (v *Vehicle) getMileage() float64 {\n    return v.mileage\n}\n\ntype Car struct {\n    Vehicle\n    numDoors int\n    fuelType string\n}\n\nfunc (c *Car) estimateFuelConsumption() float64 {\n    fuelEfficiency := 25.0 // Assuming an average fuel efficiency for cars\n    return c.mileage / fuelEfficiency\n}\n\ntype Truck struct {\n    Vehicle\n    cargoCapacity float64\n    towingCapacity float64\n}\n\nfunc (t *Truck) estimateFuelConsumption() float64 {\n    fuelEfficiency := 15.0 // Assuming a lower fuel efficiency for trucks\n    return t.mileage / fuelEfficiency\n}\n\ntype Motorcycle struct {\n    Vehicle\n    engineDisplacement int\n    numCylinders       int\n}\n\nfunc (m *Motorcycle) estimateFuelConsumption() float64 {\n    fuelEfficiency := 50.0 // Assuming a higher fuel efficiency for motorcycles\n    return m.mileage / fuelEfficiency\n}\n\ntype TransportationCompany struct {\n    vehicles []Vehicle\n}\n\nfunc (tc *TransportationCompany) addVehicle(v Vehicle) {\n    tc.vehicles = append(tc.vehicles, v)\n}\n\nfunc (tc *TransportationCompany) calculateTotalFuelConsumption() float64 {\n    totalFuelConsumption := 0.0\n    for _, v := range tc.vehicles {\n        switch vehicle := v.(type) {\n        case *Car:\n            totalFuelConsumption += vehicle.estimateFuelConsumption()\n        case *Truck:\n            totalFuelConsumption += vehicle.estimateFuelConsumption()\n        case *Motorcycle:\n            totalFuelConsumption += vehicle.estimateFuelConsumption()\n        }\n    }\n    return totalFuelConsumption\n}\n\nfunc main() {\n    company := TransportationCompany{}\n\n    car := &Car{Vehicle{\"Toyota\", \"Camry\", 2020, 10000}, 4, \"Gasoline\"}\n    truck := &Truck{Vehicle{\"Ford\", \"F-150\", 2019, 20000}, 1500, 7000}\n    motorcycle := &Motorcycle{Vehicle{\"Honda\", \"CBR600RR\", 2021, 5000}, 600, 4}\n\n    company.addVehicle(car)\n    company.addVehicle(truck)\n    company.addVehicle(motorcycle)\n\n    totalFuelConsumption := company.calculateTotalFuelConsumption()\n    fmt.Printf(\"Total fuel consumption: %.2f\\n\", totalFuelConsumption)\n}\n```",
        "explanation": "The solution demonstrates the use of inheritance in object-oriented programming using Golang. The base `Vehicle` struct contains common properties shared by all vehicles, such as make, model, year, and mileage. The derived structs `Car`, `Truck`, and `Motorcycle` inherit from the `Vehicle` struct and add their own specific attributes.\n\nThe `estimateFuelConsumption()` method is implemented for each derived vehicle type, calculating the",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system in Go to model a university registration system. The system should have the following classes: Student, Course, Professor, and Department. Implement inheritance where appropriate. The Student class should have methods to register for a course, drop a course, and view their enrolled courses. The Course class should have methods to add a student, remove a student, and get the list of enrolled students. The Professor class should have methods to teach a course and view the courses they are teaching. The Department class should have methods to add a course, remove a course, and get the list of offered courses. Demonstrate the usage of the system by creating instances of the classes and invoking their methods.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Student struct {\n    name     string\n    courses  []*Course\n}\n\nfunc (s *Student) registerCourse(c *Course) {\n    s.courses = append(s.courses, c)\n    c.addStudent(s)\n}\n\nfunc (s *Student) dropCourse(c *Course) {\n    for i, course := range s.courses {\n        if course == c {\n            s.courses = append(s.courses[:i], s.courses[i+1:]...)\n            c.removeStudent(s)\n            break\n        }\n    }\n}\n\nfunc (s *Student) viewCourses() {\n    fmt.Printf(\"Student %s is enrolled in:\\n\", s.name)\n    for _, course := range s.courses {\n        fmt.Printf(\"- %s\\n\", course.name)\n    }\n}\n\ntype Course struct {\n    name      string\n    students  []*Student\n    professor *Professor\n}\n\nfunc (c *Course) addStudent(s *Student) {\n    c.students = append(c.students, s)\n}\n\nfunc (c *Course) removeStudent(s *Student) {\n    for i, student := range c.students {\n        if student == s {\n            c.students = append(c.students[:i], c.students[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (c *Course) getStudents() []*Student {\n    return c.students\n}\n\ntype Professor struct {\n    name    string\n    courses []*Course\n}\n\nfunc (p *Professor) teachCourse(c *Course) {\n    p.courses = append(p.courses, c)\n    c.professor = p\n}\n\nfunc (p *Professor) viewCourses() {\n    fmt.Printf(\"Professor %s is teaching:\\n\", p.name)\n    for _, course := range p.courses {\n        fmt.Printf(\"- %s\\n\", course.name)\n    }\n}\n\ntype Department struct {\n    name    string  \n    courses []*Course\n}\n\nfunc (d *Department) addCourse(c *Course) {\n    d.courses = append(d.courses, c)\n}\n\nfunc (d *Department) removeCourse(c *Course) {\n    for i, course := range d.courses {\n        if course == c {\n            d.courses = append(d.courses[:i], d.courses[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (d *Department) getCourses() []*Course {\n    return d.courses  \n}\n\nfunc main() {\n    // Create instances\n    student1 := &Student{name: \"Alice\"}\n    student2 := &Student{name: \"Bob\"}\n    professor1 := &Professor{name: \"Dr. Smith\"}\n    course1 := &Course{name: \"Math101\"} \n    course2 := &Course{name: \"CS201\"}\n    department := &Department{name: \"Science\"}\n\n    // Register students for courses\n    student1.registerCourse(course1)\n    student2.registerCourse(course1)\n    student1.registerCourse(course2)\n\n    // Assign professor to courses  \n    professor1.teachCourse(course1)\n    professor1.teachCourse(course2)\n\n    // Add courses to department\n    department.addCourse(course1) \n    department.addCourse(course2)\n\n    //",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of vehicles in a transportation company. The system should support different types of vehicles (e.g., cars, trucks, buses) and allow for the management of vehicle assignments to drivers. Each vehicle should have properties such as make, model, year, and license plate number. Drivers should have properties like name, license number, and contact information. The system should also keep track of maintenance records for each vehicle, including service dates and details. Implement the necessary structs, interfaces, and methods to create a functional prototype of the vehicle management system in Go.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle interface {\n    AssignDriver(driver *Driver)\n    GetDriverInfo() string\n    AddMaintenanceRecord(record *MaintenanceRecord)\n    GetMaintenanceHistory() []*MaintenanceRecord\n}\n\ntype Car struct {\n    Make  string\n    Model string\n    Year  int\n    LicensePlate string\n    Driver *Driver\n    MaintenanceRecords []*MaintenanceRecord\n}\n\nfunc (c *Car) AssignDriver(driver *Driver) {\n    c.Driver = driver\n}\n\nfunc (c *Car) GetDriverInfo() string {\n    if c.Driver != nil {\n        return fmt.Sprintf(\"Driver: %s (License: %s)\", c.Driver.Name, c.Driver.LicenseNumber)\n    }\n    return \"No driver assigned\"\n}\n\nfunc (c *Car) AddMaintenanceRecord(record *MaintenanceRecord) {\n    c.MaintenanceRecords = append(c.MaintenanceRecords, record)\n}\n\nfunc (c *Car) GetMaintenanceHistory() []*MaintenanceRecord {\n    return c.MaintenanceRecords\n}\n\ntype Truck struct {\n    Make  string\n    Model string\n    Year  int\n    LicensePlate string\n    Driver *Driver\n    MaintenanceRecords []*MaintenanceRecord\n}\n\nfunc (t *Truck) AssignDriver(driver *Driver) {\n    t.Driver = driver\n}\n\nfunc (t *Truck) GetDriverInfo() string {\n    if t.Driver != nil {\n        return fmt.Sprintf(\"Driver: %s (License: %s)\", t.Driver.Name, t.Driver.LicenseNumber)\n    }\n    return \"No driver assigned\"\n}\n\nfunc (t *Truck) AddMaintenanceRecord(record *MaintenanceRecord) {\n    t.MaintenanceRecords = append(t.MaintenanceRecords, record)\n}\n\nfunc (t *Truck) GetMaintenanceHistory() []*MaintenanceRecord {\n    return t.MaintenanceRecords\n}\n\ntype Bus struct {\n    Make  string\n    Model string\n    Year  int\n    LicensePlate string\n    Driver *Driver\n    MaintenanceRecords []*MaintenanceRecord\n}\n\nfunc (b *Bus) AssignDriver(driver *Driver) {\n    b.Driver = driver\n}\n\nfunc (b *Bus) GetDriverInfo() string {\n    if b.Driver != nil {\n        return fmt.Sprintf(\"Driver: %s (License: %s)\", b.Driver.Name, b.Driver.LicenseNumber)\n    }\n    return \"No driver assigned\"\n}\n\nfunc (b *Bus) AddMaintenanceRecord(record *MaintenanceRecord) {\n    b.MaintenanceRecords = append(b.MaintenanceRecords, record)\n}\n\nfunc (b *Bus) GetMaintenanceHistory() []*MaintenanceRecord {\n    return b.MaintenanceRecords\n}\n\ntype Driver struct {\n    Name  string\n    LicenseNumber string\n    ContactInfo string\n}\n\ntype MaintenanceRecord struct {\n    Date string\n    Details string\n",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a car rental service using inheritance in Go. Create a base `Vehicle` struct with common attributes and methods, and then define child structs for specific vehicle types (e.g., `Car`, `Motorcycle`, `Truck`) that inherit from the base struct and have their own unique attributes and methods. Implement a `RentalService` struct that manages a collection of vehicles and provides methods for adding vehicles, removing vehicles, and calculating rental costs based on the vehicle type and rental duration. Ensure that the system is extensible and follows best practices for inheritance and polymorphism in Go.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    make  string\n    model string\n    year  int\n    dailyRentalRate float64\n}\n\nfunc (v Vehicle) getRentalCost(days int) float64 {\n    return float64(days) * v.dailyRentalRate\n}\n\ntype Car struct {\n    Vehicle\n    numSeats int\n}\n\ntype Motorcycle struct {\n    Vehicle\n    engineDisplacement int\n}\n\ntype Truck struct {\n    Vehicle\n    cargoCapacity int\n}\n\ntype RentalService struct {\n    vehicles []Vehicle\n}\n\nfunc (rs *RentalService) addVehicle(v Vehicle) {\n    rs.vehicles = append(rs.vehicles, v)\n}\n\nfunc (rs *RentalService) removeVehicle(index int) {\n    rs.vehicles = append(rs.vehicles[:index], rs.vehicles[index+1:]...)\n}\n\nfunc (rs *RentalService) getTotalRentalCost(days int) float64 {\n    var totalCost float64\n    for _, v := range rs.vehicles {\n        totalCost += v.getRentalCost(days)\n    }\n    return totalCost\n}\n\nfunc main() {\n    rentalService := RentalService{}\n\n    car := Car{Vehicle{\"Toyota\", \"Camry\", 2022, 50.0}, 5}\n    motorcycle := Motorcycle{Vehicle{\"Honda\", \"CBR600RR\", 2021, 80.0}, 599}\n    truck := Truck{Vehicle{\"Ford\", \"F-150\", 2023, 100.0}, 1500}\n\n    rentalService.addVehicle(car)\n    rentalService.addVehicle(motorcycle)\n    rentalService.addVehicle(truck)\n\n    days := 7\n    totalCost := rentalService.getTotalRentalCost(days)\n    fmt.Printf(\"Total rental cost for %d days: $%.2f\\n\", days, totalCost)\n}\n```",
        "explanation": "The solution demonstrates a well-structured use of inheritance in Go to model different types of vehicles in a car rental service. The `Vehicle` struct serves as the base struct, containing common attributes (`make`, `model`, `year`, `dailyRentalRate`) and a method (`getRentalCost`) that calculates the rental cost based on the number of rental days. The `Car`, `Motorcycle`, and `Truck` structs embed the `Vehicle` struct, inheriting its attributes and methods, and add their own specific attributes.\n\nThe `RentalService` struct manages a collection of vehicles using a slice of `Vehicle` structs. It provides methods for adding vehicles (`addVehicle`), removing vehicles (`removeVehicle`), and calculating the total rental cost for all vehicles (`getTotalRentalCost`). The `getTotalRentalCost` method leverages polymorphism by iterating over the `vehicles` slice and calling the `getRentalCost` method on each vehicle, which is dynamically dispatched based on the actual vehicle type.\n\nThis design allows for easy extensibility, as new vehicle types can be added by creating additional structs that embed the `Vehicle` struct and define their own attributes and methods as needed. The use of the",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a car rental service using inheritance in Go. The system should support cars, trucks, and motorcycles, each with their own unique attributes and methods. Implement the following:\n\n1. Create a base `Vehicle` struct with common fields like `make`, `model`, `year`, and `dailyRentalRate`.\n2. Define three structs: `Car`, `Truck`, and `Motorcycle`, that inherit from the `Vehicle` struct.\n   - `Car` should have additional fields for `numDoors` and `fuelType`.\n   - `Truck` should have additional fields for `cargoCapacity` and `numAxles`.\n   - `Motorcycle` should have an additional field for `engineDisplacement`.\n3. Implement a `RentalCost(days int)` method for each vehicle type that calculates the total rental cost based on the daily rental rate and the number of rental days.\n4. Create a `VehicleFleet` struct that contains a slice of `Vehicle` pointers.\n5. Implement an `AddVehicle(v Vehicle)` method for the `VehicleFleet` struct that appends a vehicle to the fleet.\n6. Implement a `TotalRentalCost(days int)` method for the `VehicleFleet` struct that calculates the total rental cost for all vehicles in the fleet.",
        "answer": "```go\ntype Vehicle struct {\n    make  string\n    model string\n    year  int\n    dailyRentalRate float64\n}\n\ntype Car struct {\n    Vehicle\n    numDoors int\n    fuelType string\n}\n\ntype Truck struct {\n    Vehicle\n    cargoCapacity int\n    numAxles      int\n}\n\ntype Motorcycle struct {\n    Vehicle\n    engineDisplacement int\n}\n\nfunc (c Car) RentalCost(days int) float64 {\n    return c.dailyRentalRate * float64(days)\n}\n\nfunc (t Truck) RentalCost(days int) float64 {\n    return t.dailyRentalRate * float64(days) * 1.1 // 10% surcharge for trucks\n}\n\nfunc (m Motorcycle) RentalCost(days int) float64 {\n    return m.dailyRentalRate * float64(days) * 0.9 // 10% discount for motorcycles\n}\n\ntype VehicleFleet struct {\n    vehicles []Vehicle\n}\n\nfunc (vf *VehicleFleet) AddVehicle(v Vehicle) {\n    vf.vehicles = append(vf.vehicles, v)\n}\n\nfunc (vf VehicleFleet) TotalRentalCost(days int) float64 {\n    var totalCost float64\n    for _, v := range vf.vehicles {\n        switch v := v.(type) {\n        case Car:\n            totalCost += v.RentalCost(days)\n        case Truck:\n            totalCost += v.RentalCost(days)\n        case Motorcycle:\n            totalCost += v.RentalCost(days)\n        }\n    }\n    return totalCost\n}\n```",
        "explanation": "The solution demonstrates the use of inheritance in Go using struct embedding. The `Vehicle` struct serves as the base struct, containing common fields for all vehicle types. The `Car`, `Truck`, and `Motorcycle` structs embed the `Vehicle` struct, inheriting its fields and methods.\n\nEach vehicle type implements its own `RentalCost` method, which calculates the rental cost based on the daily rental rate and the number of rental days. This allows for different pricing strategies for each vehicle type. In this example, trucks have a 10% surcharge, while motorcycles have a 10% discount.\n\nThe `VehicleFleet` struct represents a collection of vehicles and is composed of a slice of `Vehicle` pointers. The `AddVehicle` metho",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of self-driving vehicles in Golang. The system should handle tasks such as vehicle registration, route planning, and real-time monitoring. Implement the following features:\n\n1. Define a `Vehicle` struct with fields for ID, current location, destination, and status (available, in-transit, or maintenance).\n2. Create a `Fleet` struct that maintains a map of registered vehicles, keyed by their ID.\n3. Implement methods for the `Fleet` struct to register new vehicles, update vehicle status and location, and assign routes to available vehicles.\n4. Define a `Route` struct with fields for start location, end location, and estimated time of arrival (ETA).\n5. Create a `Dispatcher` struct that assigns routes to vehicles based on their availability and location.\n6. Implement a method for the `Dispatcher` struct to find the nearest available vehicle to a given location.\n7. Use goroutines and channels to simulate real-time updates of vehicle locations and status.\n8. Ensure thread-safety when modifying the `Fleet` and `Dispatcher` structs.\n\nYour task is to design and implement the system architecture, define the necessary structs and methods, and create a sample usage scenario demonstrating the system's functionality.",
        "answer": "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"sync\"\n    \"time\"\n)\n\ntype Location struct {\n    X float64\n    Y float64\n}\n\ntype VehicleStatus string\n\nconst (\n    Available   VehicleStatus = \"available\"\n    InTransit   VehicleStatus = \"in-transit\"\n    Maintenance VehicleStatus = \"maintenance\"\n)\n\ntype Vehicle struct {\n    ID          string\n    Location    Location\n    Destination Location\n    Status      VehicleStatus\n}\n\ntype Route struct {\n    Start Location\n    End   Location\n    ETA   time.Duration\n}\n\ntype Fleet struct {\n    Vehicles map[string]*Vehicle\n    mu       sync.RWMutex\n}\n\nfunc NewFleet() *Fleet {\n    return &Fleet{\n        Vehicles: make(map[string]*Vehicle),\n    }\n}\n\nfunc (f *Fleet) RegisterVehicle(vehicle *Vehicle) {\n    f.mu.Lock()\n    defer f.mu.Unlock()\n    f.Vehicles[vehicle.ID] = vehicle\n}\n\nfunc (f *Fleet) UpdateVehicleStatus(vehicleID string, status VehicleStatus) {\n    f.mu.Lock()\n    defer f.mu.Unlock()\n    if vehicle, ok := f.Vehicles[vehicleID]; ok {\n        vehicle.Status = status\n    }\n}\n\nfunc (f *Fleet) UpdateVehicleLocation(vehicleID string, location Location) {\n    f.mu.Lock()\n    defer f.mu.Unlock()\n    if vehicle, ok := f.Vehicles[vehicleID]; ok {\n        vehicle.Location = location\n    }\n}\n\ntype Dispatcher struct {\n    Fleet *Fleet\n}\n\nfunc NewDispatcher(fleet *Fleet) *Dispatcher {\n    return &Dispatcher{\n        Fleet: fleet,\n    }\n}\n\nfunc (d *Dispatcher) FindNearestVehicle(location Location) *Vehicle {\n    var nearestVehicle *Vehicle\n    var minDistance float64\n\n    d.Fleet.mu.RLock()\n    defer d.Fleet.mu.RUnlock()\n\n    for _, vehicle := range d.Fleet.Vehicles {\n        if vehicle.Status == Available {\n            distance := d.calculateDistance(location, vehicle.Location)\n            if nearestVehicle == nil || distance < minDistance {\n                nearestVehicle = vehicle\n                minDistance = distance\n            }\n        }\n    }\n\n    return nearestVehicle",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of self-driving vehicles for a ride-hailing service. The system should handle vehicle assignment, routing, charging, and maintenance. Key requirements include maximizing vehicle utilization, minimizing wait times, ensuring vehicle availability, and optimizing routes for efficiency. The system should be fault-tolerant, scalable, and secure.\n\nDefine the main components, classes, and interfaces needed for this system. Describe the relationships and interactions between them. Explain how the system would handle a ride request from a user, from vehicle assignment through completion of the ride.",
        "answer": "```golang\npackage main\n\nimport \"fmt\"\n\n// VehicleManager interfaces and abstract other vehicle management operations \ntype VehicleManager interface {\n    AssignVehicle(*RideRequest) *Vehicle\n    ReleaseVehicle(*Vehicle)\n    MonitorVehicle(*Vehicle)\n}\n\n// Router interfaces for calculating routes\ntype Router interface {\n    CalculateRoute(*RideRequest) *Route\n    OptimizeRoute(*Route, []*Vehicle)\n}\n\n// Vehicle represents a self-driving vehicle in the fleet\ntype Vehicle struct {\n    ID         int\n    Status     string\n    Position   *Location\n    Passengers []*Passenger\n    Battery    int\n}\n\n// RideRequest represents a user's request for a ride\ntype RideRequest struct {\n    ID            int\n    Passenger     *Passenger\n    PickupPoint   *Location\n    DropoffPoint  *Location\n    CompletedTime int\n}\n\n// RideManager handles ride requests and vehicle assignments\ntype RideManager struct {\n    VehicleMgr VehicleManager\n    Router     Router\n}\n\n// RequestRide processes a ride request and assigns a vehicle\nfunc (rm *RideManager) RequestRide(req *RideRequest) *Ride {\n    vehicle := rm.VehicleMgr.AssignVehicle(req)\n    route := rm.Router.CalculateRoute(req)\n    rm.Router.OptimizeRoute(route, []*Vehicle{vehicle})\n\n    ride := &Ride{\n        Request: req,\n        Vehicle: vehicle,\n        Route:   route,\n        Status:  \"InProgress\",\n    }\n    go rm.MonitorRide(ride)\n\n    return ride\n}\n\n// CompleteRide marks a ride as completed and releases the vehicle\nfunc (rm *RideManager) CompleteRide(ride *Ride) {\n    ride.Status = \"Completed\"\n    ride.CompletionTime = getCurrentTime() \n    rm.VehicleMgr.ReleaseVehicle(ride.Vehicle)\n}\n\n// MonitorRide monitors the status of an ongoing ride\nfunc (rm *RideManager) MonitorRide(ride *Ride) {\n    rm.VehicleMgr.MonitorVehicle(ride.Vehicle)\n    // Periodically check ride status and update\n    // If ride completed, call CompleteRide\n}\n```",
        "explanation": "This system design separates concerns using interfaces and structs:\n\n- The `VehicleManager` interface abstracts vehicle management, including assignment, release, and monitoring. This allows different implementations for managing vehicles.\n\n- The `Router` interface defines route calculation and optimization. The system can use various routing algorithms interchangeably. \n\n- The `Vehicle` struct represents a self-driving car, encapsulating its state and data.\n\n- The `RideRequest` struct encapsulates ride details like passenger, pickup/dropoff locations, etc.\n\n- The `RideManager` struct coordinates the interactions between components. It depends on `VehicleManager` and `Router` interfaces, allowing easy testing and modification of those parts.\n\nWhen a ride is requested:\n1. `RideManager` assigns an available `Vehicle` through the `VehicleManager`.\n2. It calculates the optimal `Route` using the `Router`.\n3. It creates a `Ride",
        "level": "advanced"
    },
    {
        "exercise": "Design a generic interface called 'Shape' with methods 'Area() float64' and 'Perimeter() float64'. Implement this interface for types 'Rectangle', 'Circle', and 'Triangle'. Rectangle should have fields 'Width' and 'Height', Circle should have field 'Radius', and Triangle should have fields 'SideA', 'SideB', and 'SideC'. \n\nCreate a function 'TotalArea' that takes a slice of Shape objects and returns the total area of all shapes. Similarly, create a function 'TotalPerimeter' that returns the total perimeter of all shapes.\n\nDemonstrate usage of these types and functions in a main program that creates a slice of various shapes and prints the total area and perimeter.",
        "answer": "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\ntype Rectangle struct {\n    Width  float64\n    Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n    return 2 * (r.Width + r.Height)\n}\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return math.Pi * c.Radius * c.Radius\n}\n\nfunc (c Circle) Perimeter() float64 {\n    return 2 * math.Pi * c.Radius\n}\n\ntype Triangle struct {\n    SideA float64\n    SideB float64 \n    SideC float64\n}\n\nfunc (t Triangle) Area() float64 {\n    s := (t.SideA + t.SideB + t.SideC) / 2\n    return math.Sqrt(s * (s - t.SideA) * (s - t.SideB) * (s - t.SideC))\n}\n\nfunc (t Triangle) Perimeter() float64 {\n    return t.SideA + t.SideB + t.SideC\n}\n\nfunc TotalArea(shapes []Shape) float64 {\n    var total float64\n    for _, s := range shapes {\n        total += s.Area()\n    }\n    return total\n}\n\nfunc TotalPerimeter(shapes []Shape) float64 {\n    var total float64\n    for _, s := range shapes {\n        total += s.Perimeter() \n    }\n    return total\n}\n\nfunc main() {\n    shapes := []Shape{\n        Rectangle{Width: 3, Height: 4},\n        Circle{Radius: 5},\n        Triangle{SideA: 3, SideB: 4, SideC: 5},\n    }\n\n    totalArea := TotalArea(shapes)\n    totalPerimeter := TotalPerimeter(shapes)\n\n    fmt.Printf(\"Total Area: %.2f\\n\", totalArea)\n    fmt.Printf(\"Total Perimeter: %.2f\\n\", totalPerimeter)\n}\n```",
        "explanation": "This solution demonstrates several key object-oriented principles in Go:\n\n1. Polymorphism: The Shape interface defines a common set of methods (Area and Perimeter) that each concrete shape type (Rectangle, Circle, Triangle) must implement. This allows treating objects of different types uniformly through the common interface.\n\n2. Encapsulation: The shape types encapsulate their internal state (fields like Width, Height, Radius, etc.) and provide methods to interact with that state. The internal representation is hidden from outside code.\n\n3. Abstraction: The Shape interface provides an abstraction layer that hides the implementation details of each shape. Code that uses the Shape interface doesn't need to know about the concrete types.\n\n4. Composition: While Go doesn't have classical inheritance, it supports composition. The Shape interface is a form of composition that allows different types to be used interchangeably.\n\nThe TotalArea and TotalPerimeter functions demonstrate the power of polymorphism. They accept a slice of Shape objects and can calculate properties of different shapes without needing to know the concrete type. This makes the code more flexible and extensible.\n\nOne advantage of this design is that new shape types can",
        "level": "advanced"
    },
    {
        "exercise": "Design a hierarchical structure for a university management system in Golang. The system should have the following types: University, Faculty, Department, Course, Instructor, and Student. Implement the following requirements: \n1. University contains multiple Faculties \n2. Each Faculty contains multiple Departments \n3. Each Department offers multiple Courses \n4. Each Course is taught by one Instructor \n5. Each Course is attended by multiple Students \n6. Instructors and Students should have methods to get their details \n7. Courses should have methods to enroll a Student, assign an Instructor, and get the list of enrolled Students \nImplement this system using inheritance, encapsulation and polymorphism in Golang. Also provide a main function that demonstrates the usage of this university management system.",
        "answer": "```go\npackage main\n\nimport \"fmt\"\n\ntype Person struct {\n  name string\n  age  int\n}\n\nfunc (p Person) getDetails() string {\n  return fmt.Sprintf(\"Name: %s, Age: %d\", p.name, p.age)\n}\n\ntype Student struct {\n  Person\n  studentID  string\n  department *Department\n}\n\ntype Instructor struct {\n  Person\n  instructorID string\n  department   *Department\n}\n\ntype Course struct {\n  name         string\n  courseID     string\n  instructor   *Instructor\n  students     []*Student\n  department   *Department\n}\n\nfunc (c *Course) assignInstructor(instructor *Instructor) {\n  c.instructor = instructor\n}\n\nfunc (c *Course) enrollStudent(student *Student) {\n  c.students = append(c.students, student)\n}\n\nfunc (c *Course) getEnrolledStudents() []*Student {\n  return c.students\n}\n\ntype Department struct {\n  name    string\n  courses []*Course\n  faculty *Faculty\n}\n\ntype Faculty struct {\n  name        string \n  departments []*Department\n  university  *University\n}\n\ntype University struct {\n  name      string\n  faculties []*Faculty\n}\n\nfunc main() {\n  // Create a university\n  university := &University{name: \"ABC University\"}\n  \n  // Create faculties\n  engineeringFaculty := &Faculty{name: \"Engineering\", university: university}  \n  university.faculties = append(university.faculties, engineeringFaculty)\n  \n  // Create departments\n  csDepartment := &Department{name: \"Computer Science\", faculty: engineeringFaculty}\n  engineeringFaculty.departments = append(engineeringFaculty.departments, csDepartment)\n  \n  // Create courses\n  course1 := &Course{name: \"Programming 101\", courseID: \"CS101\", department: csDepartment}\n  csDepartment.courses = append(csDepartment.courses, course1)\n  \n  // Create instructor\n  instructor1 := &Instructor{Person: Person{name: \"John Doe\", age: 35}, instructorID: \"I101\", department: csDepartment}\n  course1.assignInstructor(instructor1)\n  \n  // Create students \n  student1 := &Student{Person: Person{name: \"Alice\", age: 20}, studentID: \"S101\", department: csDepartment}\n  student2 := &Student{Person: Person{name: \"Bob\", age: 21}, studentID: \"S102\", department: csDepartment}\n  course1.enrollStudent(student1)\n  course1.enrollStudent(student2)\n  \n  // Print details\n  fmt.Printf(\"University: %s\\n\", university.name)\n  fmt.Printf(\"Faculty: %s\\n\", engineeringFaculty.name)\n  fmt.Printf(\"Department: %s\\n\", c",
        "level": "advanced"
    },
    {
        "exercise": "Design an object-oriented system in Golang to model a generic file system. The system should support the following features:\n\n1. A base `FileSystemNode` interface that defines common methods for all nodes, such as `GetName()`, `GetSize()`, and `GetCreationTime()`.\n\n2. Two derived structs, `File` and `Directory`, that implement the `FileSystemNode` interface.\n   - `File` should have properties for name, size, creation time, and content.\n   - `Directory` should have properties for name, creation time, and a slice of `FileSystemNode`s representing its contents.\n\n3. Implement methods for `Directory`:\n   - `AddNode(node FileSystemNode)` to add a file or directory to the current directory.\n   - `RemoveNode(name string)` to remove a file or directory with the given name.\n   - `GetNode(name string)` to retrieve a file or directory with the given name.\n   - `GetSize()` to calculate the total size of the directory and its contents recursively.\n\n4. Ensure that the `GetSize()` method for both `File` and `Directory` returns the size in bytes.\n\n5. Create a `Print()` method for both `File` and `Directory` that displays the name and size of the node. For directories, it should also print the contents recursively with indentation.\n\nImplement the necessary structs, interfaces, and methods to create a working file system hierarchy. Demonstrate the usage of your file system by creating a sample directory structure with files and subdirectories, and print the structure using the `Print()` method.",
        "answer": "```golang\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\ntype FileSystemNode interface {\n    GetName() string\n    GetSize() int64\n    GetCreationTime() time.Time\n    Print(indent string)\n}\n\ntype File struct {\n    name         string\n    size         int64\n    creationTime time.Time\n    content      string\n}\n\nfunc (f *File) GetName() string {\n    return f.name\n}\n\nfunc (f *File) GetSize() int64 {\n    return f.size\n}\n\nfunc (f *File) GetCreationTime() time.Time {\n    return f.creationTime\n}\n\nfunc (f *File) Print(indent string) {\n    fmt.Printf(\"%s- %s (File, Size: %d bytes)\\n\", indent, f.name, f.size)\n}\n\ntype Directory struct {\n    name         string\n    creationTime time.Time\n    contents     []FileSystemNode\n}\n\nfunc (d *Directory) GetName() string {\n    return d.name\n}\n\nfunc (d *Directory) GetSize() int64 {\n    totalSize := int64(0)\n    for _, node := range d.contents {\n        totalSize += node.GetSize()\n    }\n    return totalSize\n}\n\nfunc (d *Directory) GetCreationTime() time.Time {\n    return d.creationTime\n}\n\nfunc (d *Directory) AddNode(node FileSystemNode) {\n    d.contents = append(d.contents, node)\n}\n\nfunc (d *Directory) RemoveNode(name string) {\n    for i, node := range d.contents {\n        if node.GetName() == name {\n            d.contents = append(d.contents[:i], d.contents[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (d *Directory) GetNode(name string) FileSystemNode {\n    for _, node := range d.contents {\n        if node.GetName() == name {\n            return node\n        }\n    }\n    return nil\n}\n\nfunc (d *Directory) Print(indent string) {\n    fmt.Printf(\"%s- %s (Directory, Size: %d bytes)\\n\", indent, d.name, d.GetSize())\n    for _, node := range d.contents {\n        node.Print(indent + \"  \")\n    }\n}\n\nfunc main() {\n    rootDir := &Directory{name: \"root\", creationTime: time.Now()}\n\n    file1 := &File{name: \"file1.txt\", size: 100,",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing different types of vehicles in a rental agency using object-oriented principles in Go. The system should support cars, trucks, and motorcycles. Each vehicle type should have common properties like make, model, year, and rental price, but also type-specific properties and methods. For example, cars have a number of doors, trucks have cargo capacity, and motorcycles have an engine size. Implement an inheritance hierarchy to share common functionality and specialize behavior for each vehicle type. Also provide a way to calculate the rental price for a vehicle based on a base daily rate and a type-specific multiplier (e.g. 1x for cars, 1.5x for trucks, 0.8x for motorcycles). Finally, create a RentalAgency struct that tracks all the vehicles and allows renting vehicles to customers.",
        "answer": "```go\n// Vehicle is the base struct for all vehicle types\ntype Vehicle struct {\n    make  string\n    model string\n    year  int\n    dailyRate float64\n}\n\n// Car represents a car vehicle\ntype Car struct {\n    Vehicle\n    numDoors int\n}\n\n// DailyRate calculates the daily rental rate for a car\nfunc (c Car) DailyRate() float64 {\n    return c.dailyRate\n}\n\n// Truck represents a truck vehicle \ntype Truck struct {\n    Vehicle\n    cargoCapacity int\n}\n\n// DailyRate calculates the daily rental rate for a truck\nfunc (t Truck) DailyRate() float64 {\n    return t.dailyRate * 1.5\n}\n\n// Motorcycle represents a motorcycle vehicle\ntype Motorcycle struct {  \n    Vehicle\n    engineSize int\n}\n\n// DailyRate calculates the daily rental rate for a motorcycle\nfunc (m Motorcycle) DailyRate() float64 {\n    return m.dailyRate * 0.8\n}\n\n// RentalAgency manages a collection of vehicles for rent\ntype RentalAgency struct {\n    vehicles []Vehicle\n}\n\n// AddVehicle adds a new vehicle to the rental agency\nfunc (r *RentalAgency) AddVehicle(v Vehicle) {\n    r.vehicles = append(r.vehicles, v)\n}\n\n// GetVehicles returns all vehicles in the rental agency\nfunc (r *RentalAgency) GetVehicles() []Vehicle {\n    return r.vehicles \n}\n```",
        "explanation": "This solution demonstrates an inheritance hierarchy in Go to model different types of vehicles in a rental agency system. The `Vehicle` struct serves as the base type containing common fields for all vehicles like `make`, `model`, `year` and base `dailyRate`. \n\nThe specialized vehicle types `Car`, `Truck` and `Motorcycle` embed the `Vehicle` struct to inherit its fields and behavior. Each specialized type adds its own unique fields - `numDoors` for `Car`, `cargoCapacity` for `Truck`, and `engineSize` for `Motorcycle`.\n\nEach vehicle type also implements a `DailyRate()` method to calculate its specific rental rate by multiplying the base `dailyRate` with a type-specific modifier - 1x for `Car`, 1.5x for `Truck` and 0.8x for `Motorcycle`. Method overriding allows providing different implementations for each type.\n\nThe `RentalAgency` struct maintains a fleet of vehicles in a slice field. Methods are provided to add a new vehicle and get the list of all vehicles. The `RentalAgency` methods accept the `Vehicle` interface, allowing any of the specific vehicle types to be used.\n\nThis design adheres to key OOP principles:\n- Encapsulation: Data like `make`, `model`, and rates are encapsulated within structs.\n- Inheritance: Common attributes & behavior are shared via embedding `Vehicle`.  \n- Polymorphism: `DailyRate()` method is overridden by each specific type. `RentalAgency` works with the common `Vehicle` interface.\n\nAdvantages:\n- Code reuse through embedding shared `Vehicle` fields & behavior\n- Flexibility to add more vehicle types \n- Polymorphic behavior via overriding and interfaces\n\nDisadvantages:  \n- Go only supports embedding, not full class-based inheritance\n- Changes to base `Vehicle` affect all types\n- Potential for",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a university course catalog using object-oriented principles in Go. The system should support the following:\n\n1. Courses: Each course has a name, code, description, instructor, and a list of prerequisites. \n2. Departments: Each department has a name, code, and a list of courses offered.\n3. Instructors: Each instructor has a name, ID, and a list of courses they teach.\n4. Students: Each student has a name, ID, major, and a list of completed courses.\n\nYour task is to design the structs and methods for this system. Include methods for:\n- Adding/removing courses from departments and instructors \n- Enrolling students in courses (checking prerequisites)\n- Determining if a student can graduate based on completed courses\n\nUtilize appropriate OOP concepts like composition, encapsulation and inheritance where applicable.",
        "answer": "```go\ntype Course struct {\n    Name          string\n    Code          string \n    Description   string\n    Prerequisites []*Course\n    Instructor    *Instructor\n}\n\ntype Department struct {\n    Name    string\n    Code    string\n    Courses []*Course\n}\n\nfunc (d *Department) AddCourse(c *Course) {\n    d.Courses = append(d.Courses, c)\n}\n\nfunc (d *Department) RemoveCourse(c *Course) {\n    for i, course := range d.Courses {\n        if course == c {\n            d.Courses = append(d.Courses[:i], d.Courses[i+1:]...)\n            break\n        }\n    }\n}\n\ntype Instructor struct {\n    Name    string\n    ID      int\n    Courses []*Course\n}\n\nfunc (i *Instructor) AddCourse(c *Course) {\n    i.Courses = append(i.Courses, c)\n    c.Instructor = i\n}\n\nfunc (i *Instructor) RemoveCourse(c *Course) {\n    for j, course := range i.Courses {\n        if course == c {\n            i.Courses = append(i.Courses[:j], i.Courses[j+1:]...)\n            break \n        }\n    }\n}\n\ntype Student struct {\n    Name     string\n    ID       int\n    Major    *Department\n    Courses  []*Course\n}\n\nfunc (s *Student) CompleteCourse(c *Course) {\n    s.Courses = append(s.Courses, c)\n}\n\nfunc (s *Student) EnrollInCourse(c *Course) error {\n    for _, prereq := range c.Prerequisites {\n        found := false\n        for _, completed := range s.Courses {\n            if completed == prereq {\n                found = true\n                break\n            }\n        }\n        if !found {\n            return fmt.Errorf(",
        "level": "advanced"
    },
    {
        "exercise": "Design a flexible and extensible plugin system in Go that allows for dynamic loading and unloading of plugins at runtime. The system should support plugins of different types (e.g., authentication, logging, caching) and provide a way for plugins to communicate with each other and with the main application. Implement the necessary interfaces, structs, and functions to create a working plugin system.",
        "answer": "```go\n// Plugin is the interface that all plugins must implement\ntype Plugin interface {\n    Name() string\n    Description() string \n    Version() string\n    Start() error\n    Stop() error\n}\n\n// PluginManager manages the lifecycle of plugins\ntype PluginManager struct {\n    plugins map[string]Plugin\n}\n\n// NewPluginManager creates a new PluginManager\nfunc NewPluginManager() *PluginManager {\n    return &PluginManager{\n        plugins: make(map[string]Plugin),\n    }\n}\n\n// LoadPlugin loads a plugin by its file path\nfunc (pm *PluginManager) LoadPlugin(path string) error {\n    // Load plugin using plugin.Open(path)\n    // Check if loaded plugin implements Plugin interface \n    // Store in plugins map\n    // Call Start() on the plugin\n}\n\n// UnloadPlugin unloads a plugin by its name\nfunc (pm *PluginManager) UnloadPlugin(name string) error {\n    // Check if plugin exists in plugins map\n    // Call Stop() on the plugin\n    // Remove from plugins map\n}\n\n// Plugins returns the currently loaded plugins\nfunc (pm *PluginManager) Plugins() []Plugin {\n    // Return slice of loaded Plugin interfaces\n}\n\n// Example plugin types\ntype LoggerPlugin struct {}\ntype AuthPlugin struct {}\n\nfunc (l *LoggerPlugin) Name() string { return \"Logger\" }  \nfunc (l *LoggerPlugin) Description() string { return \"Logging plugin\" }\nfunc (l *LoggerPlugin) Version() string { return \"1.0.0\" }\nfunc (l *LoggerPlugin) Start() error { /* Init logger */ }  \nfunc (l *LoggerPlugin) Stop() error { /* Clean up */ }\n\nfunc (a *AuthPlugin) Name() string { return \"Auth\" } \nfunc (a *AuthPlugin) Description() string { return \"Auth plugin\" }\nfunc (a *AuthPlugin) Version() string { return \"1.0.1\" } \nfunc (a *AuthPlugin) Start() error { /* Init auth */ }\nfunc (a *AuthPlugin) Stop() error { /* Clean up */ }\n```",
        "explanation": "The plugin system is designed using interfaces in Go to allow for flexibility and extensibility. The `Plugin` interface defines the contract that all plugins must adhere to, including methods for retrieving metadata about the plugin and controlling its lifecycle.\n\nThe `PluginManager` is responsible for managing the loading, unloading, and storage of plugins. It maintains a map of loaded plugins, where the key is the plugin name and the value is an instance of the `Plugin` interface. \n\nWhen loading a plugin, the manager uses the `plugin` package in Go to dynamically load the plugin file. It then checks if the loaded plugin implements the `Plugin` interface and stores it in the plugins map. The `Start()` method is called to initialize the plugin.\n\nTo unload a plugin, the manager retrieves the plugin from the map, calls the `Stop()` method to clean up any resources, and removes it from the map.\n\nThe `Plugins()` method returns a slice of all currently loaded plugins.\n\nExample plugin types, `LoggerPlugin` and `AuthPlugin`, are provided to demonstrate how plugins can be implemented for different purposes. Each plugin struct implements the methods required by the `Plugin` interface.\n\nThis design allows for easy addition and removal of plugins at runtime, without the need to recompile the main application. Plugins can be developed independently and loaded dynamically as needed. The use of interfaces provides a clear contract for plugin developers to follow and ensures that plugins can be used interchangeably.\n\nHowever, this design also has some drawbacks. Loading untrusted plugins can potentially introduce security risks, so proper validation and sandboxing mechanisms should be put in place. Versioning and compatibility issues may arise if plugin and application versions are not managed carefully. Plugin dependencies and inter-plugin communication can also add complexity to the system.\n\nOverall, this plugin system provides a solid foundation for building extens",
        "level": "advanced"
    },
    {
        "exercise": "Design a vehicle inventory management system using object-oriented principles in Golang. The system should support multiple vehicle types (e.g., cars, trucks, motorcycles) and allow for the management of vehicle information, such as make, model, year, price, and availability status. Implement the following functionality:\n\n1. Define base vehicle struct and interfaces for common operations.\n2. Create structs for each vehicle type that embed the base vehicle struct and implement the interfaces.\n3. Implement methods for adding, removing, and updating vehicles in the inventory.\n4. Allow searching for vehicles based on various criteria (e.g., vehicle type, make, model, price range).\n5. Provide a way to display the details of a specific vehicle and the total number of vehicles in the inventory.\n\nEnsure that the system is extensible and follows best practices for inheritance and composition in Golang.",
        "answer": "```golang\npackage main\n\nimport \"fmt\"\n\ntype Vehicle struct {\n    Make  string\n    Model string\n    Year  int\n    Price float64\n}\n\ntype VehicleOperations interface {\n    AddVehicle(vehicle Vehicle)\n    RemoveVehicle(vehicle Vehicle)\n    UpdateVehicle(vehicle Vehicle)\n    SearchVehicles(criteria map[string]interface{}) []Vehicle\n    DisplayVehicle(vehicle Vehicle)\n    GetTotalVehicles() int\n}\n\ntype Car struct {\n    Vehicle\n    NumDoors int\n}\n\ntype Truck struct {\n    Vehicle\n    CargoCapacity float64\n}\n\ntype Motorcycle struct {\n    Vehicle\n    EngineDisplacement int\n}\n\ntype Inventory struct {\n    vehicles []Vehicle\n}\n\nfunc (i *Inventory) AddVehicle(vehicle Vehicle) {\n    i.vehicles = append(i.vehicles, vehicle)\n}\n\nfunc (i *Inventory) RemoveVehicle(vehicle Vehicle) {\n    for index, v := range i.vehicles {\n        if v == vehicle {\n            i.vehicles = append(i.vehicles[:index], i.vehicles[index+1:]...)\n            break\n        }\n    }\n}\n\nfunc (i *Inventory) UpdateVehicle(vehicle Vehicle) {\n    for index, v := range i.vehicles {\n        if v == vehicle {\n            i.vehicles[index] = vehicle\n            break\n        }\n    }\n}\n\nfunc (i *Inventory) SearchVehicles(criteria map[string]interface{}) []Vehicle {\n    var matchingVehicles []Vehicle\n    for _, vehicle := range i.vehicles {\n        match := true\n        for key, value := range criteria {\n            switch key {\n            case \"Make\":\n                if vehicle.Make != value.(string) {\n                    match = false\n                }\n            case \"Model\":\n                if vehicle.Model != value.(string) {\n                    match = false\n                }\n            case \"Year\":\n                if vehicle.Year != value.(int) {\n                    match = false\n                }\n            case \"Price\":\n                if vehicle.Price > value.(float64) {\n                    match = false\n                }\n            }\n        }\n        if match {\n            matchingVehicles = append(matchingVehicles, vehicle)\n        }\n    }\n    return matchingVehicles\n}\n\nfunc (i *Inventory) DisplayVehicle(vehicle Vehicle) {\n    fmt.Printf(\"Make: %s\\nModel: %s\\nYear: %d\\nPrice: $%.2f\\n\", vehicle.Make, vehicle.Model, vehicle.Year, vehicle.Price)\n}\n\nfunc (i *Inventory) GetTotalVehicles() int {\n    return len(i.vehicles)\n}\n```",
        "explanation": "The provided solution demonstrates the use of inheritance and composition in Golang to design a vehicle inventory management system. Here's a breakdown of the key concepts",
        "level": "advanced"
    },
    {
        "exercise": "Design a system for managing a fleet of autonomous vehicles using object-oriented principles in Go. The system should handle vehicle registration, assignment of vehicles to customers, real-time monitoring of vehicle location and status, and automatic dispatch of the nearest available vehicle to a customer requesting a ride.\n\nRequirements:\n- Use appropriate abstractions and encapsulation to model vehicles, customers, and the fleet manager \n- Implement methods for registering new vehicles, updating vehicle status, requesting rides, and optimally assigning vehicles to customers\n- Ensure thread-safety for concurrent access to shared resources\n- Use interfaces where appropriate to allow for flexibility and extensibility\n- Provide a simulation or demonstration of the system with sample inputs",
        "answer": "```go\n// Vehicle represents an autonomous vehicle in the fleet\ntype Vehicle struct {\n    ID     string\n    Status string\n    Location Location\n}\n\n// SetStatus updates the vehicle's status\nfunc (v *Vehicle) SetStatus(status string) {\n    v.Status = status\n}\n\n// Customer represents a customer requesting a ride\ntype Customer struct {\n    ID       string\n    Location Location\n}\n\n// Location represents a geographic location\ntype Location struct {\n    Latitude  float64\n    Longitude float64\n}\n\n// FleetManager manages the fleet of vehicles and handles ride requests\ntype FleetManager struct {\n    Vehicles  map[string]*Vehicle\n    Customers map[string]*Customer\n    mutex     sync.Mutex\n}\n\n// RegisterVehicle adds a new vehicle to the fleet\nfunc (fm *FleetManager) RegisterVehicle(vehicle *Vehicle) {\n    fm.mutex.Lock()\n    defer fm.mutex.Unlock()\n    fm.Vehicles[vehicle.ID] = vehicle\n}\n\n// UpdateVehicleStatus updates the status of a vehicle\nfunc (fm *FleetManager) UpdateVehicleStatus(vehicleID, status string) {\n    fm.mutex.Lock()\n    defer fm.mutex.Unlock()\n    if vehicle, ok := fm.Vehicles[vehicleID]; ok {\n        vehicle.SetStatus(status)\n    }\n}\n\n// RequestRide handles a customer's request for a ride\nfunc (fm *FleetManager) RequestRide(customerID string, location Location) *Vehicle {\n    fm.mutex.Lock()\n    defer fm.mutex.Unlock()\n\n    // Find the nearest available vehicle\n    var nearestVehicle *Vehicle\n    minDistance := math.Inf(1)\n    for _, vehicle := range fm.Vehicles {\n        if vehicle.Status == \"available\" {\n            distance := calculateDistance(vehicle.Location, location)\n            if distance < minDistance {\n                minDistance = distance\n                nearestVehicle = vehicle\n            }\n        }\n    }\n\n    // Assign the vehicle to the customer\n    if nearestVehicle != nil {\n        nearestVehicle.SetStatus(\"assigned\")\n    }\n\n    return nearestVehicle\n}\n\n// calculateDistance calculates the distance between two locations\nfunc calculateDistance(loc1, loc2 Location) float64 {\n    // Implementation of distance calculation algorithm\n    // (e.g., Haversine formula) goes here\n    // ...\n}\n```",
        "explanation": "The solution demonstrates key object-oriented principles:\n\n- Encapsulation: The `Vehicle`, `Customer`, and `Location` structs encapsulate related data and behavior. The `Vehicle` struct's `Status` field is private, and its value is modified through the `SetStatus` method, ensuring controlled access.\n\n- Abstraction: The `FleetManager` struct provides a high-level interface for managing vehicles and handling ride requests, abstracting away the low-level details of vehicle assignment and distance calculation. \n\n- Modularity: The code is organized into separate structs and methods, each with a specific responsibility. This promotes code reusability and maintainability.\n\n- Thread-safety: The `FleetManager` struct uses a mutex to synchronize access to its shared resources (`Vehicles` and `Customers` maps), preventing data races in concurrent scenarios.\n\nThe `RequestRide` method showcases the core functionality of assigning the nearest available vehicle to a customer. It finds the vehicle with the minimum distance to the customer's location using the `calculateDistance` function (implementation not shown for brevity).\n\nTo make the solution more extensible, interfaces could be introduced. For example, a `Locatable` interface",
        "level": "advanced"
    },
    {
        "exercise": "Design a flexible and extensible system for managing a fleet of vehicles for a transportation company. The system should handle different types of vehicles (e.g., cars, trucks, motorcycles) and allow for easy addition of new vehicle types in the future. Each vehicle should have properties such as make, model, year, and license plate number. The system should also manage drivers, including their name, license number, and the type of vehicles they are allowed to operate. Implement methods for assigning drivers to vehicles based on their qualifications, and for calculating the total number of vehicles of each type in the fleet.",
        "answer": "```go\n// Vehicle interface defines common methods for all vehicles\ntype Vehicle interface {\n    getMake() string\n    getModel() string\n    getYear() int\n    getLicensePlate() string\n}\n\n// Car struct implements the Vehicle interface for cars\ntype Car struct {\n    make  string\n    model string\n    year  int\n    licensePlate string\n}\n\nfunc (c Car) getMake() string {\n    return c.make\n}\n\nfunc (c Car) getModel() string {\n    return c.model\n}\n\nfunc (c Car) getYear() int {\n    return c.year\n}\n\nfunc (c Car) getLicensePlate() string {\n    return c.licensePlate\n}\n\n// Truck struct implements the Vehicle interface for trucks\ntype Truck struct {\n    make  string\n    model string\n    year  int\n    licensePlate string\n}\n\nfunc (t Truck) getMake() string {\n    return t.make\n}\n\nfunc (t Truck) getModel() string {\n    return t.model\n}\n\nfunc (t Truck) getYear() int {\n    return t.year\n}\n\nfunc (t Truck) getLicensePlate() string {\n    return t.licensePlate\n}\n\n// Driver struct represents a driver with their qualifications\ntype Driver struct {\n    name string\n    licenseNumber string\n    qualifiedVehicles []string\n}\n\n// FleetManager struct manages the vehicles and drivers\ntype FleetManager struct {\n    vehicles []Vehicle\n    drivers  []Driver\n}\n\n// RegisterVehicle adds a new vehicle to the fleet\nfunc (fm *FleetManager) RegisterVehicle(vehicle Vehicle) {\n    fm.vehicles = append(fm.vehicles, vehicle)\n}\n\n// RegisterDriver adds a new driver to the fleet\nfunc (fm *FleetManager) RegisterDriver(driver Driver) {\n    fm.drivers = append(fm.drivers, driver)\n}\n\n// AssignDriver assigns a driver to a vehicle based on qualifications\nfunc (fm *FleetManager) AssignDriver(vehicle Vehicle, driver Driver) error {\n    vehicleType := reflect.TypeOf(vehicle).Name()\n    for _, qualifiedVehicle := range driver.qualifiedVehicles {\n        if qualifiedVehicle == vehicleType {\n            return nil\n        }\n    }\n    return fmt.Errorf(",
        "level": "advanced"
    },
    {
        "exercise": "Design a Go package called 'vehicle' that models different types of vehicles using object-oriented principles. The package should include base structs called 'Vehicle' and 'Engine'. Then create specialized vehicle types that inherit from Vehicle and compose an Engine:\n\n- Car: has 4 wheels and uses a combustion engine\n- Motorcycle: has 2 wheels and uses a combustion engine  \n- ElectricCar: has 4 wheels and uses an electric engine\n\nVehicle should contain methods for starting and stopping the engine. Car and Motorcycle should have a method for driving that takes a distance parameter. ElectricCar should have a method for driving that takes a distance and checks the battery level.\n\nProvide all necessary struct definitions, interfaces, and method implementations. Demonstrate creating instances of each vehicle type in a main function.",
        "answer": "```go\npackage vehicle\n\ntype Vehicle struct {\n  NumWheels int\n  Engine    Engine\n  IsRunning bool  \n}\n\nfunc (v *Vehicle) StartEngine() {\n  v.IsRunning = true\n  v.Engine.Start()\n}\n\nfunc (v *Vehicle) StopEngine() {\n  v.IsRunning = false\n  v.Engine.Stop()  \n}\n\ntype Engine interface {\n  Start()\n  Stop()\n}\n\ntype CombustionEngine struct{}\n\nfunc (ce CombustionEngine) Start() {}\nfunc (ce CombustionEngine) Stop() {}\n\ntype ElectricEngine struct {\n  BatteryLevel int\n}\n\nfunc (ee *ElectricEngine) Start() {}\n\nfunc (ee *ElectricEngine) Stop() {}\n\ntype Car struct {\n  Vehicle\n}\n\nfunc NewCar() Car {\n  return Car{Vehicle{NumWheels: 4, Engine: CombustionEngine{}}}\n}\n\nfunc (c *Car) Drive(distance int) {\n  // logic for driving car distance\n}\n\ntype Motorcycle struct { \n  Vehicle\n}\n\nfunc NewMotorcycle() Motorcycle {\n  return Motorcycle{Vehicle{NumWheels: 2, Engine: CombustionEngine{}}}\n}\n\nfunc (m *Motorcycle) Drive(distance int) {\n  // logic for driving motorcycle distance\n}\n\ntype ElectricCar struct {\n  Vehicle \n  BatteryLevel int\n}\n\nfunc NewElectricCar(batteryLevel int) ElectricCar {\n  return ElectricCar{\n    Vehicle: Vehicle{\n      NumWheels: 4, \n      Engine: &ElectricEngine{BatteryLevel: batteryLevel},\n    },\n    BatteryLevel: batteryLevel,\n  }\n}\n  \nfunc (ec *ElectricCar) Drive(distance int) {\n  if ec.BatteryLevel > 0 {\n    // logic for driving electric car distance\n    ec.BatteryLevel -= distance\n  }\n}\n\nfunc main() {\n\n  car := NewCar()\n  car.StartEngine()\n  car.Drive(10)\n  car.StopEngine()\n\n  motorcycle := NewMotorcycle() \n  motorcycle.StartEngine()\n  motorcycle.Drive(5)\n  motorcycle.StopEngine()\n  \n  eCar := NewElectricCar(100)\n  eCar.StartEngine() \n  eCar.Drive(20)\n  eCar.StopEngine()\n}\n```",
        "explanation": "This Go package demonstrates key object-oriented principles through modeling different vehicle types:\n\nInheritance: The specialized vehicle types Car, Motorcycle, and ElectricCar inherit common fields and methods from the base Vehicle struct. This allows code reuse.\n\nPolymorphism: Car/Motorcycle and ElectricCar provide their own implementation of the Drive method, exhibiting polymorphic behavior. Each overrides it to perform driving logic specific to that vehicle type.\n\nComposition: Car and Motorcycle embed Vehicle, while ElectricCar embeds Vehicle and also composes an ElectricEngine. Composition allows creating new types by combining existing types.\n\nEncapsulation: Fields are encapsulated within their respective structs. Public methods StartEngine, StopEngine, and Drive provide controlled access to the internal state.\n\nAbstraction: The Engine interface abstracts the engine implementation from vehicles. This allows different engine types (combustion vs electric",
        "level": "advanced"
    }
]